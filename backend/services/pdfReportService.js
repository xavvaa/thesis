let PDFDocument;
try {
  PDFDocument = require('pdfkit');
} catch (error) {
  console.error('PDFKit not found. Please install it with: npm install pdfkit');
  PDFDocument = null;
}

const fs = require('fs');
const path = require('path');

class PDFReportService {
  constructor() {
    this.logoPath = path.join(__dirname, '../assets/logo.png'); // Add your logo here
    this.colors = {
      primary: '#2563eb',
      secondary: '#64748b',
      accent: '#059669',
      danger: '#dc2626',
      warning: '#d97706',
      text: '#374151',
      lightGray: '#f8fafc',
      darkGray: '#1f2937'
    };
  }

  async generateReportPDF(reportData, reportName = 'Report') {
    if (!PDFDocument) {
      throw new Error('PDFKit library not available. Please install it with: npm install pdfkit');
    }
    
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: 'A4',
          margins: { top: 50, bottom: 50, left: 50, right: 50 }
        });

        const chunks = [];
        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Add header
        this.addHeader(doc, reportName, reportData.reportMetadata);
        
        // Add content based on report type
        this.addReportContent(doc, reportData);
        
        // Add footer
        this.addFooter(doc, reportData.reportMetadata);

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  addHeader(doc, reportName, metadata) {
    const pageWidth = doc.page.width - 100; // Account for margins
    
    // Header background with gradient effect (simulated)
    doc.rect(50, 50, pageWidth, 100)
       .fill(this.colors.primary);
    
    // Accent bar
    doc.rect(50, 50, 10, 100)
       .fill(this.colors.accent);

    // Logo placeholder (if logo exists)
    // doc.image(this.logoPath, 70, 60, { width: 60, height: 60 });

    // Title - Dynamic report name
    doc.fill('white')
       .fontSize(26)
       .font('Helvetica-Bold')
       .text(reportName, 70, 65, { width: pageWidth - 250 });

    // Subtitle
    doc.fontSize(11)
       .font('Helvetica')
       .text('Public Employment Service Office (PESO)', 70, 100);

    // Report info box - Dynamic metadata
    const infoBoxX = pageWidth - 180;
    doc.fontSize(9)
       .font('Helvetica')
       .fill('white')
       .text('Generated:', infoBoxX, 65)
       .text(new Date(metadata.generatedAt).toLocaleString(), infoBoxX, 78)
       .text('Period:', infoBoxX, 95)
       .text(`${metadata.startDate} to`, infoBoxX, 108)
       .text(metadata.endDate, infoBoxX, 121);
    
    // Add generated by info if available
    if (metadata.generatedBy) {
      doc.fontSize(8)
         .text(`By: ${metadata.generatedBy}`, infoBoxX, 134);
    }

    // Move cursor down
    doc.y = 170;
  }

  addReportContent(doc, reportData) {
    const { data } = reportData;
    
    // Summary Section
    if (data.summary) {
      this.addSummarySection(doc, data.summary);
    }

    // Charts/Visualizations (text-based for now)
    if (data.registrationTrends) {
      this.addTrendsSection(doc, data.registrationTrends, 'Registration Trends');
    }

    // Detailed Data Section
    if (data.details && data.details.length > 0) {
      this.addDetailsSection(doc, data.details);
    }

    // Additional sections based on report type
    this.addAdditionalSections(doc, data, reportData.reportMetadata.reportType);
  }

  addSummarySection(doc, summary) {
    const startY = doc.y + 20;
    
    // Section title
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text('Executive Summary', 50, startY);

    doc.y = startY + 30;

    // Summary cards - improved layout with 3 columns
    const pageWidth = doc.page.width - 100;
    const cardWidth = (pageWidth - 40) / 3; // 3 cards per row with spacing
    const cardHeight = 90;
    const cardSpacing = 20;
    let currentX = 50;
    let currentY = doc.y;
    let cardIndex = 0;

    Object.entries(summary).forEach(([key, value]) => {
      if (cardIndex > 0 && cardIndex % 3 === 0) {
        currentY += cardHeight + cardSpacing;
        currentX = 50;
      }

      // Card shadow effect
      doc.rect(currentX + 2, currentY + 2, cardWidth, cardHeight)
         .fill('#e5e7eb');

      // Card background
      doc.rect(currentX, currentY, cardWidth, cardHeight)
         .fill('white')
         .stroke(this.colors.secondary);

      // Card title
      doc.fontSize(9)
         .font('Helvetica')
         .fill(this.colors.secondary)
         .text(this.formatLabel(key), currentX + 15, currentY + 20, {
           width: cardWidth - 30,
           align: 'left'
         });

      // Card value
      doc.fontSize(24)
         .font('Helvetica-Bold')
         .fill(this.colors.primary)
         .text(this.formatValue(value), currentX + 15, currentY + 40, {
           width: cardWidth - 30,
           align: 'left'
         });

      currentX += cardWidth + cardSpacing;
      cardIndex++;
    });

    doc.y = currentY + cardHeight + 40;
  }

  addTrendsSection(doc, trends, title) {
    const startY = doc.y + 20;
    
    // Section title
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text(title, 50, startY);

    doc.y = startY + 40;

    // Simple text-based chart representation
    doc.fontSize(10)
       .font('Helvetica')
       .fill(this.colors.text);

    trends.slice(0, 10).forEach((trend, index) => {
      const date = `${trend._id.year}-${String(trend._id.month).padStart(2, '0')}-${String(trend._id.day).padStart(2, '0')}`;
      const role = trend._id.role || 'N/A';
      const count = trend.count;
      
      doc.text(`${date} | ${role.padEnd(12)} | ${'â–ˆ'.repeat(Math.min(count, 20))} (${count})`, 50, doc.y + 5);
    });

    doc.y += 40;
  }

  addDetailsSection(doc, details) {
    const startY = doc.y + 20;
    
    // Section title
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text('Detailed Data', 50, startY);

    doc.y = startY + 30;

    // Table headers with smart column widths
    const headers = Object.keys(details[0] || {});
    const pageWidth = doc.page.width - 100;
    
    // Calculate optimal column widths based on content
    const columnWidths = this.calculateColumnWidths(headers, details, pageWidth);
    
    // Header row with gradient effect
    doc.rect(50, doc.y, pageWidth, 30)
       .fill(this.colors.primary);

    doc.fontSize(10)
       .font('Helvetica-Bold')
       .fill('white');

    let currentX = 55;
    headers.forEach((header, index) => {
      doc.text(this.formatLabel(header), currentX, doc.y + 10, {
        width: columnWidths[index] - 10,
        ellipsis: true
      });
      currentX += columnWidths[index];
    });

    doc.y += 30;

    // Data rows with better spacing and borders
    const maxRows = 25;
    details.slice(0, maxRows).forEach((row, rowIndex) => {
      const rowY = doc.y;
      const rowHeight = 28;
      const isEven = rowIndex % 2 === 0;
      
      // Alternate row colors with subtle borders
      if (isEven) {
        doc.rect(50, rowY, pageWidth, rowHeight)
           .fill(this.colors.lightGray);
      }
      
      // Add subtle row border
      doc.moveTo(50, rowY + rowHeight)
         .lineTo(50 + pageWidth, rowY + rowHeight)
         .strokeColor('#e5e7eb')
         .lineWidth(0.5)
         .stroke();

      doc.fontSize(9)
         .font('Helvetica')
         .fill(this.colors.text);

      currentX = 55;
      headers.forEach((header, index) => {
        const value = this.formatCellValue(row[header]);
        
        // Add vertical separators between columns
        if (index > 0) {
          doc.moveTo(currentX - 5, rowY)
             .lineTo(currentX - 5, rowY + rowHeight)
             .strokeColor('#e5e7eb')
             .lineWidth(0.5)
             .stroke();
        }
        
        doc.text(value, currentX, rowY + 9, {
          width: columnWidths[index] - 10,
          ellipsis: true
        });
        currentX += columnWidths[index];
      });

      doc.y = rowY + rowHeight;

      // Page break if needed
      if (doc.y > doc.page.height - 100) {
        doc.addPage();
        doc.y = 50;
        
        // Re-add header on new page
        doc.rect(50, doc.y, pageWidth, 30)
           .fill(this.colors.primary);
        doc.fontSize(10)
           .font('Helvetica-Bold')
           .fill('white');
        currentX = 55;
        headers.forEach((header, index) => {
          doc.text(this.formatLabel(header), currentX, doc.y + 10, {
            width: columnWidths[index] - 10,
            ellipsis: true
          });
          currentX += columnWidths[index];
        });
        doc.y += 30;
      }
    });

    if (details.length > maxRows) {
      doc.fontSize(10)
         .font('Helvetica-Oblique')
         .fill(this.colors.secondary)
         .text(`... and ${details.length - maxRows} more records (showing first ${maxRows})`, 50, doc.y + 10);
    }

    doc.y += 40;
  }

  calculateColumnWidths(headers, details, totalWidth) {
    // Smart column width calculation
    const minWidth = 60;
    const maxWidth = 150;
    
    // Calculate content-based widths
    const contentWidths = headers.map((header, index) => {
      const headerLength = this.formatLabel(header).length * 7;
      const maxContentLength = Math.max(
        ...details.slice(0, 10).map(row => 
          String(this.formatCellValue(row[header])).length * 6
        )
      );
      return Math.min(Math.max(headerLength, maxContentLength, minWidth), maxWidth);
    });
    
    // Normalize to fit page width
    const totalContentWidth = contentWidths.reduce((a, b) => a + b, 0);
    const scale = totalWidth / totalContentWidth;
    
    return contentWidths.map(w => w * scale);
  }

  addAdditionalSections(doc, data, reportType) {
    switch (reportType) {
      case 'system-health':
        if (data.summary && data.summary.memoryUsage) {
          this.addSystemHealthSection(doc, data.summary);
        }
        break;
      
      case 'verification-report':
        this.addVerificationMetrics(doc, data.summary);
        break;
      
      // Add more specific sections as needed
    }
  }

  addSystemHealthSection(doc, summary) {
    const startY = doc.y + 20;
    
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text('System Health Metrics', 50, startY);

    doc.y = startY + 30;

    if (summary.memoryUsage) {
      const memory = summary.memoryUsage;
      doc.fontSize(12)
         .font('Helvetica')
         .fill(this.colors.text)
         .text(`Memory Usage:`, 50, doc.y)
         .text(`  RSS: ${(memory.rss / 1024 / 1024).toFixed(2)} MB`, 70, doc.y + 15)
         .text(`  Heap Used: ${(memory.heapUsed / 1024 / 1024).toFixed(2)} MB`, 70, doc.y + 30)
         .text(`  Heap Total: ${(memory.heapTotal / 1024 / 1024).toFixed(2)} MB`, 70, doc.y + 45);
    }

    if (summary.systemUptime) {
      const uptime = Math.floor(summary.systemUptime / 3600);
      doc.text(`System Uptime: ${uptime} hours`, 50, doc.y + 70);
    }

    doc.y += 100;
  }

  addVerificationMetrics(doc, summary) {
    if (!summary) return;

    const startY = doc.y + 20;
    
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text('Verification Metrics', 50, startY);

    doc.y = startY + 30;

    const total = (summary.pendingEmployers || 0) + (summary.verifiedEmployers || 0) + (summary.rejectedEmployers || 0);
    
    if (total > 0) {
      const pendingRate = ((summary.pendingEmployers || 0) / total * 100).toFixed(1);
      const approvalRate = ((summary.verifiedEmployers || 0) / total * 100).toFixed(1);
      const rejectionRate = ((summary.rejectedEmployers || 0) / total * 100).toFixed(1);

      doc.fontSize(12)
         .font('Helvetica')
         .fill(this.colors.text)
         .text(`Approval Rate: ${approvalRate}%`, 50, doc.y)
         .text(`Rejection Rate: ${rejectionRate}%`, 50, doc.y + 20)
         .text(`Pending Rate: ${pendingRate}%`, 50, doc.y + 40);
    }

    doc.y += 80;
  }

  addFooter(doc, metadata) {
    const pageHeight = doc.page.height;
    const footerY = pageHeight - 80;

    // Footer line
    doc.moveTo(50, footerY)
       .lineTo(doc.page.width - 50, footerY)
       .stroke(this.colors.secondary);

    // Footer text
    doc.fontSize(8)
       .font('Helvetica')
       .fill(this.colors.secondary)
       .text('Public Employment Service Office (PESO) - Confidential Report', 50, footerY + 10)
       .text(`Generated on ${new Date(metadata.generatedAt).toLocaleDateString()}`, 50, footerY + 25)
       .text(`Page 1`, doc.page.width - 100, footerY + 10);
  }

  formatLabel(key) {
    // Convert camelCase to Title Case with proper spacing
    return key
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .trim();
  }

  formatValue(value) {
    if (typeof value === 'number') {
      // Format numbers with commas and handle decimals
      if (Number.isInteger(value)) {
        return value.toLocaleString();
      }
      return value.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    if (typeof value === 'boolean') {
      return value ? 'Yes' : 'No';
    }
    if (typeof value === 'object' && value !== null) {
      if (Array.isArray(value)) {
        return `${value.length} items`;
      }
      return JSON.stringify(value);
    }
    return String(value);
  }

  formatCellValue(value) {
    if (value === null || value === undefined) {
      return 'N/A';
    }
    if (typeof value === 'boolean') {
      return value ? 'Yes' : 'No';
    }
    if (typeof value === 'number') {
      if (Number.isInteger(value)) {
        return value.toLocaleString();
      }
      return value.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    if (typeof value === 'object') {
      if (value instanceof Date) {
        return value.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
      }
      if (Array.isArray(value)) {
        return `${value.length} items`;
      }
      return JSON.stringify(value).substring(0, 40) + '...';
    }
    const str = String(value);
    return str.length > 50 ? str.substring(0, 47) + '...' : str;
  }

  // Generate multiple reports as a single PDF
  async generateBulkReportsPDF(allReportsData) {
    if (!PDFDocument) {
      throw new Error('PDFKit library not available. Please install it with: npm install pdfkit');
    }
    
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: 'A4',
          margins: { top: 50, bottom: 50, left: 50, right: 50 }
        });

        const chunks = [];
        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Cover page
        this.addCoverPage(doc, allReportsData.metadata);

        // Table of contents
        this.addTableOfContents(doc, allReportsData.reports);

        // Individual reports
        allReportsData.reports.forEach((report, index) => {
          if (index > 0) doc.addPage();
          
          const reportName = this.getReportDisplayName(report.reportType);
          this.addHeader(doc, reportName, report.reportMetadata || allReportsData.metadata);
          this.addReportContent(doc, report);
        });

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  addCoverPage(doc, metadata) {
    const pageWidth = doc.page.width - 100;
    const pageHeight = doc.page.height - 100;

    // Title
    doc.fontSize(32)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text('PESO Reports', 50, 150, { align: 'center', width: pageWidth });

    // Subtitle
    doc.fontSize(18)
       .font('Helvetica')
       .fill(this.colors.text)
       .text('Comprehensive Analytics Report', 50, 200, { align: 'center', width: pageWidth });

    // Date range - Dynamic
    doc.fontSize(14)
       .text(`${metadata.dateRange}`, 50, 250, { align: 'center', width: pageWidth });

    // Generated info - Dynamic
    doc.fontSize(12)
       .fill(this.colors.secondary)
       .text(`Generated: ${new Date(metadata.generatedAt).toLocaleString()}`, 50, 300, { align: 'center', width: pageWidth })
       .text(`Total Reports: ${metadata.totalReports}`, 50, 320, { align: 'center', width: pageWidth });
    
    // Add generated by if available
    if (metadata.generatedBy) {
      doc.text(`Generated By: ${metadata.generatedBy}`, 50, 340, { align: 'center', width: pageWidth });
    }
    
    // Add format info
    if (metadata.format) {
      doc.text(`Format: ${metadata.format.toUpperCase()}`, 50, 360, { align: 'center', width: pageWidth });
    }

    doc.addPage();
  }

  addTableOfContents(doc, reports) {
    doc.fontSize(20)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text('Table of Contents', 50, 100);

    doc.y = 140;

    reports.forEach((report, index) => {
      const reportName = this.getReportDisplayName(report.reportType);
      const pageNum = index + 3; // Account for cover and TOC pages
      
      doc.fontSize(12)
         .font('Helvetica')
         .fill(this.colors.text)
         .text(`${index + 1}. ${reportName}`, 70, doc.y + 5)
         .text(`${pageNum}`, 500, doc.y + 5);
      
      doc.y += 25;
    });

    doc.addPage();
  }

  getReportDisplayName(reportType) {
    const displayNames = {
      'user-summary': 'User Summary Report',
      'user-registration': 'User Registration Trends',
      'user-activity': 'User Activity Analysis',
      'job-postings': 'Job Postings Overview',
      'job-performance': 'Job Performance Metrics',
      'employer-activity': 'Employer Activity Report',
      'application-summary': 'Application Summary',
      'application-trends': 'Application Trends Analysis',
      'system-health': 'System Health Report',
      'verification-report': 'Verification Status Report',
      'platform-analytics': 'Platform Analytics',
      'revenue-analytics': 'Revenue Analytics'
    };
    
    return displayNames[reportType] || reportType;
  }
}

module.exports = new PDFReportService();
