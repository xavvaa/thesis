const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

class PDFReportService {
  constructor() {
    this.logoPath = path.join(__dirname, '../assets/logo.png'); // Add your logo here
    this.colors = {
      primary: '#2563eb',
      secondary: '#64748b',
      accent: '#059669',
      danger: '#dc2626',
      warning: '#d97706',
      text: '#374151',
      lightGray: '#f8fafc',
      darkGray: '#1f2937'
    };
  }

  async generateReportPDF(reportData, reportName = 'Report') {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: 'A4',
          margins: { top: 50, bottom: 50, left: 50, right: 50 }
        });

        const chunks = [];
        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Add header
        this.addHeader(doc, reportName, reportData.reportMetadata);
        
        // Add content based on report type
        this.addReportContent(doc, reportData);
        
        // Add footer
        this.addFooter(doc, reportData.reportMetadata);

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  addHeader(doc, reportName, metadata) {
    const pageWidth = doc.page.width - 100; // Account for margins
    
    // Header background
    doc.rect(50, 50, pageWidth, 80)
       .fill(this.colors.primary);

    // Logo placeholder (if logo exists)
    // doc.image(this.logoPath, 70, 60, { width: 60, height: 60 });

    // Title
    doc.fill('white')
       .fontSize(24)
       .font('Helvetica-Bold')
       .text(reportName, 150, 70);

    // Subtitle
    doc.fontSize(12)
       .font('Helvetica')
       .text('Professional Employment Services Office (PESO)', 150, 100);

    // Report info
    doc.fill(this.colors.text)
       .fontSize(10)
       .text(`Generated: ${new Date(metadata.generatedAt).toLocaleString()}`, pageWidth - 150, 70)
       .text(`Date Range: ${metadata.startDate} to ${metadata.endDate}`, pageWidth - 150, 85)
       .text(`Format: ${metadata.format.toUpperCase()}`, pageWidth - 150, 100)
       .text(`Generated by: ${metadata.generatedBy}`, pageWidth - 150, 115);

    // Move cursor down
    doc.y = 160;
  }

  addReportContent(doc, reportData) {
    const { data } = reportData;
    
    // Summary Section
    if (data.summary) {
      this.addSummarySection(doc, data.summary);
    }

    // Charts/Visualizations (text-based for now)
    if (data.registrationTrends) {
      this.addTrendsSection(doc, data.registrationTrends, 'Registration Trends');
    }

    // Detailed Data Section
    if (data.details && data.details.length > 0) {
      this.addDetailsSection(doc, data.details);
    }

    // Additional sections based on report type
    this.addAdditionalSections(doc, data, reportData.reportMetadata.reportType);
  }

  addSummarySection(doc, summary) {
    const startY = doc.y + 20;
    
    // Section title
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text('Executive Summary', 50, startY);

    doc.y = startY + 30;

    // Summary cards
    const cardWidth = 120;
    const cardHeight = 80;
    const cardsPerRow = 4;
    let currentX = 50;
    let currentY = doc.y;
    let cardIndex = 0;

    Object.entries(summary).forEach(([key, value]) => {
      if (cardIndex > 0 && cardIndex % cardsPerRow === 0) {
        currentY += cardHeight + 20;
        currentX = 50;
      }

      // Card background
      doc.rect(currentX, currentY, cardWidth, cardHeight)
         .fill(this.colors.lightGray)
         .stroke(this.colors.secondary);

      // Card title
      doc.fontSize(10)
         .font('Helvetica-Bold')
         .fill(this.colors.text)
         .text(this.formatLabel(key), currentX + 10, currentY + 15, {
           width: cardWidth - 20,
           align: 'center'
         });

      // Card value
      doc.fontSize(20)
         .font('Helvetica-Bold')
         .fill(this.colors.primary)
         .text(this.formatValue(value), currentX + 10, currentY + 35, {
           width: cardWidth - 20,
           align: 'center'
         });

      currentX += cardWidth + 15;
      cardIndex++;
    });

    doc.y = currentY + cardHeight + 40;
  }

  addTrendsSection(doc, trends, title) {
    const startY = doc.y + 20;
    
    // Section title
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text(title, 50, startY);

    doc.y = startY + 40;

    // Simple text-based chart representation
    doc.fontSize(10)
       .font('Helvetica')
       .fill(this.colors.text);

    trends.slice(0, 10).forEach((trend, index) => {
      const date = `${trend._id.year}-${String(trend._id.month).padStart(2, '0')}-${String(trend._id.day).padStart(2, '0')}`;
      const role = trend._id.role || 'N/A';
      const count = trend.count;
      
      doc.text(`${date} | ${role.padEnd(12)} | ${'â–ˆ'.repeat(Math.min(count, 20))} (${count})`, 50, doc.y + 5);
    });

    doc.y += 40;
  }

  addDetailsSection(doc, details) {
    const startY = doc.y + 20;
    
    // Section title
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text('Detailed Data', 50, startY);

    doc.y = startY + 30;

    // Table headers
    const headers = Object.keys(details[0] || {});
    const columnWidth = (doc.page.width - 100) / headers.length;
    
    // Header row
    doc.rect(50, doc.y, doc.page.width - 100, 25)
       .fill(this.colors.primary);

    doc.fontSize(10)
       .font('Helvetica-Bold')
       .fill('white');

    headers.forEach((header, index) => {
      doc.text(this.formatLabel(header), 55 + (index * columnWidth), doc.y + 8, {
        width: columnWidth - 10,
        ellipsis: true
      });
    });

    doc.y += 25;

    // Data rows
    details.slice(0, 20).forEach((row, rowIndex) => {
      const rowY = doc.y;
      const isEven = rowIndex % 2 === 0;
      
      // Alternate row colors
      if (isEven) {
        doc.rect(50, rowY, doc.page.width - 100, 20)
           .fill(this.colors.lightGray);
      }

      doc.fontSize(9)
         .font('Helvetica')
         .fill(this.colors.text);

      headers.forEach((header, index) => {
        const value = this.formatCellValue(row[header]);
        doc.text(value, 55 + (index * columnWidth), rowY + 5, {
          width: columnWidth - 10,
          ellipsis: true
        });
      });

      doc.y = rowY + 20;

      // Page break if needed
      if (doc.y > doc.page.height - 100) {
        doc.addPage();
        doc.y = 50;
      }
    });

    if (details.length > 20) {
      doc.fontSize(10)
         .font('Helvetica-Oblique')
         .fill(this.colors.secondary)
         .text(`... and ${details.length - 20} more records`, 50, doc.y + 10);
    }

    doc.y += 40;
  }

  addAdditionalSections(doc, data, reportType) {
    switch (reportType) {
      case 'system-health':
        if (data.summary && data.summary.memoryUsage) {
          this.addSystemHealthSection(doc, data.summary);
        }
        break;
      
      case 'verification-report':
        this.addVerificationMetrics(doc, data.summary);
        break;
      
      // Add more specific sections as needed
    }
  }

  addSystemHealthSection(doc, summary) {
    const startY = doc.y + 20;
    
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text('System Health Metrics', 50, startY);

    doc.y = startY + 30;

    if (summary.memoryUsage) {
      const memory = summary.memoryUsage;
      doc.fontSize(12)
         .font('Helvetica')
         .fill(this.colors.text)
         .text(`Memory Usage:`, 50, doc.y)
         .text(`  RSS: ${(memory.rss / 1024 / 1024).toFixed(2)} MB`, 70, doc.y + 15)
         .text(`  Heap Used: ${(memory.heapUsed / 1024 / 1024).toFixed(2)} MB`, 70, doc.y + 30)
         .text(`  Heap Total: ${(memory.heapTotal / 1024 / 1024).toFixed(2)} MB`, 70, doc.y + 45);
    }

    if (summary.systemUptime) {
      const uptime = Math.floor(summary.systemUptime / 3600);
      doc.text(`System Uptime: ${uptime} hours`, 50, doc.y + 70);
    }

    doc.y += 100;
  }

  addVerificationMetrics(doc, summary) {
    if (!summary) return;

    const startY = doc.y + 20;
    
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text('Verification Metrics', 50, startY);

    doc.y = startY + 30;

    const total = (summary.pendingEmployers || 0) + (summary.verifiedEmployers || 0) + (summary.rejectedEmployers || 0);
    
    if (total > 0) {
      const pendingRate = ((summary.pendingEmployers || 0) / total * 100).toFixed(1);
      const approvalRate = ((summary.verifiedEmployers || 0) / total * 100).toFixed(1);
      const rejectionRate = ((summary.rejectedEmployers || 0) / total * 100).toFixed(1);

      doc.fontSize(12)
         .font('Helvetica')
         .fill(this.colors.text)
         .text(`Approval Rate: ${approvalRate}%`, 50, doc.y)
         .text(`Rejection Rate: ${rejectionRate}%`, 50, doc.y + 20)
         .text(`Pending Rate: ${pendingRate}%`, 50, doc.y + 40);
    }

    doc.y += 80;
  }

  addFooter(doc, metadata) {
    const pageHeight = doc.page.height;
    const footerY = pageHeight - 80;

    // Footer line
    doc.moveTo(50, footerY)
       .lineTo(doc.page.width - 50, footerY)
       .stroke(this.colors.secondary);

    // Footer text
    doc.fontSize(8)
       .font('Helvetica')
       .fill(this.colors.secondary)
       .text('Professional Employment Services Office (PESO) - Confidential Report', 50, footerY + 10)
       .text(`Generated on ${new Date(metadata.generatedAt).toLocaleDateString()}`, 50, footerY + 25)
       .text(`Page 1`, doc.page.width - 100, footerY + 10);
  }

  formatLabel(key) {
    return key.replace(/([A-Z])/g, ' $1')
              .replace(/^./, str => str.toUpperCase())
              .replace(/([a-z])([A-Z])/g, '$1 $2');
  }

  formatValue(value) {
    if (typeof value === 'number') {
      return value.toLocaleString();
    }
    if (typeof value === 'object' && value !== null) {
      return JSON.stringify(value);
    }
    return String(value);
  }

  formatCellValue(value) {
    if (value === null || value === undefined) {
      return 'N/A';
    }
    if (typeof value === 'object') {
      if (value instanceof Date) {
        return value.toLocaleDateString();
      }
      return JSON.stringify(value).substring(0, 50) + '...';
    }
    return String(value).substring(0, 50);
  }

  // Generate multiple reports as a single PDF
  async generateBulkReportsPDF(allReportsData) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: 'A4',
          margins: { top: 50, bottom: 50, left: 50, right: 50 }
        });

        const chunks = [];
        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Cover page
        this.addCoverPage(doc, allReportsData.metadata);

        // Table of contents
        this.addTableOfContents(doc, allReportsData.reports);

        // Individual reports
        allReportsData.reports.forEach((report, index) => {
          if (index > 0) doc.addPage();
          
          const reportName = this.getReportDisplayName(report.reportType);
          this.addHeader(doc, reportName, report.reportMetadata || allReportsData.metadata);
          this.addReportContent(doc, report);
        });

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  addCoverPage(doc, metadata) {
    const pageWidth = doc.page.width - 100;
    const pageHeight = doc.page.height - 100;

    // Title
    doc.fontSize(32)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text('PESO Reports', 50, 150, { align: 'center', width: pageWidth });

    // Subtitle
    doc.fontSize(18)
       .font('Helvetica')
       .fill(this.colors.text)
       .text('Comprehensive Analytics Report', 50, 200, { align: 'center', width: pageWidth });

    // Date range
    doc.fontSize(14)
       .text(`${metadata.dateRange}`, 50, 250, { align: 'center', width: pageWidth });

    // Generated info
    doc.fontSize(12)
       .fill(this.colors.secondary)
       .text(`Generated: ${new Date(metadata.generatedAt).toLocaleString()}`, 50, 300, { align: 'center', width: pageWidth })
       .text(`Total Reports: ${metadata.totalReports}`, 50, 320, { align: 'center', width: pageWidth });

    doc.addPage();
  }

  addTableOfContents(doc, reports) {
    doc.fontSize(20)
       .font('Helvetica-Bold')
       .fill(this.colors.primary)
       .text('Table of Contents', 50, 100);

    doc.y = 140;

    reports.forEach((report, index) => {
      const reportName = this.getReportDisplayName(report.reportType);
      const pageNum = index + 3; // Account for cover and TOC pages
      
      doc.fontSize(12)
         .font('Helvetica')
         .fill(this.colors.text)
         .text(`${index + 1}. ${reportName}`, 70, doc.y + 5)
         .text(`${pageNum}`, 500, doc.y + 5);
      
      doc.y += 25;
    });

    doc.addPage();
  }

  getReportDisplayName(reportType) {
    const displayNames = {
      'user-summary': 'User Summary Report',
      'user-registration': 'User Registration Trends',
      'user-activity': 'User Activity Analysis',
      'job-postings': 'Job Postings Overview',
      'job-performance': 'Job Performance Metrics',
      'employer-activity': 'Employer Activity Report',
      'application-summary': 'Application Summary',
      'application-trends': 'Application Trends Analysis',
      'system-health': 'System Health Report',
      'verification-report': 'Verification Status Report',
      'platform-analytics': 'Platform Analytics',
      'revenue-analytics': 'Revenue Analytics'
    };
    
    return displayNames[reportType] || reportType;
  }
}

module.exports = new PDFReportService();
