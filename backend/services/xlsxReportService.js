let XLSX;
try {
  XLSX = require('xlsx');
} catch (error) {
  console.warn('XLSX library not found. Please install it with: npm install xlsx');
  XLSX = null;
}

class XLSXReportService {
  constructor() {
    this.defaultStyles = {
      header: {
        font: { bold: true, color: { rgb: "FFFFFF" } },
        fill: { fgColor: { rgb: "2563EB" } },
        alignment: { horizontal: "center", vertical: "center" }
      },
      subHeader: {
        font: { bold: true, color: { rgb: "374151" } },
        fill: { fgColor: { rgb: "F3F4F6" } },
        alignment: { horizontal: "left", vertical: "center" }
      },
      data: {
        font: { color: { rgb: "374151" } },
        alignment: { horizontal: "left", vertical: "center" }
      },
      number: {
        font: { color: { rgb: "374151" } },
        alignment: { horizontal: "right", vertical: "center" },
        numFmt: "#,##0"
      },
      currency: {
        font: { color: { rgb: "374151" } },
        alignment: { horizontal: "right", vertical: "center" },
        numFmt: "$#,##0.00"
      }
    };
  }

  generateReportXLSX(reportData, reportName = 'Report') {
    if (!XLSX) {
      throw new Error('XLSX library not available. Please install it with: npm install xlsx');
    }
    
    const workbook = XLSX.utils.book_new();
    
    // Create summary sheet
    this.addSummarySheet(workbook, reportData, reportName);
    
    // Create detailed data sheet if available
    if (reportData.data.details && reportData.data.details.length > 0) {
      this.addDetailsSheet(workbook, reportData.data.details, 'Detailed Data');
    }
    
    // Create trends sheet if available
    if (reportData.data.registrationTrends || reportData.data.trends) {
      const trendsData = reportData.data.registrationTrends || reportData.data.trends;
      this.addTrendsSheet(workbook, trendsData, 'Trends Analysis');
    }
    
    // Add metadata sheet
    this.addMetadataSheet(workbook, reportData.reportMetadata);
    
    return XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
  }

  addSummarySheet(workbook, reportData, reportName) {
    const summaryData = [];
    
    // Title row
    summaryData.push([reportName]);
    summaryData.push([]); // Empty row
    
    // Report info
    summaryData.push(['Report Information']);
    summaryData.push(['Generated:', new Date(reportData.reportMetadata.generatedAt).toLocaleString()]);
    summaryData.push(['Date Range:', `${reportData.reportMetadata.startDate} to ${reportData.reportMetadata.endDate}`]);
    summaryData.push(['Generated By:', reportData.reportMetadata.generatedBy]);
    summaryData.push(['Format:', reportData.reportMetadata.format.toUpperCase()]);
    summaryData.push([]); // Empty row
    
    // Summary metrics
    if (reportData.data.summary) {
      summaryData.push(['Summary Metrics']);
      summaryData.push(['Metric', 'Value']);
      
      Object.entries(reportData.data.summary).forEach(([key, value]) => {
        const formattedKey = this.formatLabel(key);
        const formattedValue = this.formatValue(value);
        summaryData.push([formattedKey, formattedValue]);
      });
    }
    
    const worksheet = XLSX.utils.aoa_to_sheet(summaryData);
    
    // Set column widths
    worksheet['!cols'] = [
      { width: 25 }, // Metric names
      { width: 20 }  // Values
    ];
    
    // Apply basic styling (note: XLSX.js has limited styling support without pro version)
    this.applyBasicStyling(worksheet, summaryData.length);
    
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Summary');
  }

  addDetailsSheet(workbook, details, sheetName) {
    if (!details || details.length === 0) return;
    
    const headers = Object.keys(details[0]);
    const detailsData = [];
    
    // Add headers
    detailsData.push(headers.map(header => this.formatLabel(header)));
    
    // Add data rows
    details.forEach(row => {
      const dataRow = headers.map(header => this.formatCellValue(row[header]));
      detailsData.push(dataRow);
    });
    
    const worksheet = XLSX.utils.aoa_to_sheet(detailsData);
    
    // Set column widths based on content
    const colWidths = headers.map(header => ({
      width: Math.max(header.length, 15)
    }));
    worksheet['!cols'] = colWidths;
    
    // Apply styling
    this.applyBasicStyling(worksheet, detailsData.length);
    
    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
  }

  addTrendsSheet(workbook, trends, sheetName) {
    if (!trends || trends.length === 0) return;
    
    const trendsData = [];
    
    // Headers based on trend data structure
    if (trends[0]._id) {
      // Handle aggregated trend data
      trendsData.push(['Date', 'Category', 'Count']);
      
      trends.forEach(trend => {
        let dateStr = '';
        if (trend._id.year && trend._id.month && trend._id.day) {
          dateStr = `${trend._id.year}-${String(trend._id.month).padStart(2, '0')}-${String(trend._id.day).padStart(2, '0')}`;
        } else if (trend._id.year && trend._id.month) {
          dateStr = `${trend._id.year}-${String(trend._id.month).padStart(2, '0')}`;
        }
        
        const category = trend._id.role || trend._id.status || 'N/A';
        trendsData.push([dateStr, category, trend.count]);
      });
    } else {
      // Handle simple array data
      trendsData.push(['Index', 'Value']);
      trends.forEach((item, index) => {
        trendsData.push([index + 1, JSON.stringify(item)]);
      });
    }
    
    const worksheet = XLSX.utils.aoa_to_sheet(trendsData);
    
    // Set column widths
    worksheet['!cols'] = [
      { width: 15 }, // Date
      { width: 20 }, // Category
      { width: 10 }  // Count
    ];
    
    this.applyBasicStyling(worksheet, trendsData.length);
    
    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
  }

  addMetadataSheet(workbook, metadata) {
    const metadataArray = [];
    
    metadataArray.push(['Report Metadata']);
    metadataArray.push([]); // Empty row
    
    Object.entries(metadata).forEach(([key, value]) => {
      const formattedKey = this.formatLabel(key);
      let formattedValue = value;
      
      if (key.includes('Date') && value) {
        formattedValue = new Date(value).toLocaleString();
      } else if (typeof value === 'object') {
        formattedValue = JSON.stringify(value);
      }
      
      metadataArray.push([formattedKey, formattedValue]);
    });
    
    const worksheet = XLSX.utils.aoa_to_sheet(metadataArray);
    
    worksheet['!cols'] = [
      { width: 20 },
      { width: 30 }
    ];
    
    this.applyBasicStyling(worksheet, metadataArray.length);
    
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Metadata');
  }

  generateBulkReportsXLSX(allReportsData) {
    if (!XLSX) {
      throw new Error('XLSX library not available. Please install it with: npm install xlsx');
    }
    
    const workbook = XLSX.utils.book_new();
    
    // Create overview sheet
    this.addOverviewSheet(workbook, allReportsData);
    
    // Create individual sheets for each report
    allReportsData.reports.forEach((report, index) => {
      const reportName = this.getReportDisplayName(report.reportType);
      const sheetName = `${index + 1}. ${reportName}`.substring(0, 31); // Excel sheet name limit
      
      this.addIndividualReportSheet(workbook, report, sheetName);
    });
    
    return XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
  }

  addOverviewSheet(workbook, allReportsData) {
    const overviewData = [];
    
    // Title
    overviewData.push(['PESO Reports Overview']);
    overviewData.push([]);
    
    // Metadata
    overviewData.push(['Generated:', new Date(allReportsData.metadata.generatedAt).toLocaleString()]);
    overviewData.push(['Date Range:', allReportsData.metadata.dateRange]);
    overviewData.push(['Total Reports:', allReportsData.metadata.totalReports]);
    overviewData.push(['Failed Reports:', allReportsData.metadata.failedReports || 0]);
    overviewData.push([]);
    
    // Reports list
    overviewData.push(['Report Index', 'Report Name', 'Type', 'Status']);
    
    allReportsData.reports.forEach((report, index) => {
      const reportName = this.getReportDisplayName(report.reportType);
      overviewData.push([
        index + 1,
        reportName,
        report.reportType,
        'Generated'
      ]);
    });
    
    const worksheet = XLSX.utils.aoa_to_sheet(overviewData);
    
    worksheet['!cols'] = [
      { width: 12 }, // Index
      { width: 30 }, // Name
      { width: 20 }, // Type
      { width: 15 }  // Status
    ];
    
    this.applyBasicStyling(worksheet, overviewData.length);
    
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Overview');
  }

  addIndividualReportSheet(workbook, report, sheetName) {
    const reportData = [];
    
    // Report title
    const reportDisplayName = this.getReportDisplayName(report.reportType);
    reportData.push([reportDisplayName]);
    reportData.push([]);
    
    // Summary data
    if (report.data && report.data.summary) {
      reportData.push(['Summary']);
      reportData.push(['Metric', 'Value']);
      
      Object.entries(report.data.summary).forEach(([key, value]) => {
        reportData.push([this.formatLabel(key), this.formatValue(value)]);
      });
      
      reportData.push([]);
    }
    
    // Detailed data (limited to first 100 rows for performance)
    if (report.data && report.data.details && report.data.details.length > 0) {
      reportData.push(['Detailed Data (First 100 records)']);
      
      const details = report.data.details.slice(0, 100);
      const headers = Object.keys(details[0]);
      
      reportData.push(headers.map(h => this.formatLabel(h)));
      
      details.forEach(row => {
        const dataRow = headers.map(header => this.formatCellValue(row[header]));
        reportData.push(dataRow);
      });
    }
    
    const worksheet = XLSX.utils.aoa_to_sheet(reportData);
    
    // Auto-size columns
    const maxCols = Math.max(...reportData.map(row => row.length));
    worksheet['!cols'] = Array(maxCols).fill({ width: 15 });
    
    this.applyBasicStyling(worksheet, reportData.length);
    
    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
  }

  applyBasicStyling(worksheet, rowCount) {
    // Note: Basic XLSX.js has limited styling capabilities
    // For advanced styling, consider using exceljs or xlsx-style
    
    // Set row heights for headers
    if (!worksheet['!rows']) worksheet['!rows'] = [];
    
    // Make first row (title) taller
    worksheet['!rows'][0] = { hpt: 25 };
    
    // Auto-filter for data tables (if applicable)
    if (rowCount > 2) {
      const range = XLSX.utils.decode_range(worksheet['!ref']);
      if (range.e.r > 1) {
        worksheet['!autofilter'] = { ref: worksheet['!ref'] };
      }
    }
  }

  formatLabel(key) {
    return key.replace(/([A-Z])/g, ' $1')
              .replace(/^./, str => str.toUpperCase())
              .replace(/([a-z])([A-Z])/g, '$1 $2');
  }

  formatValue(value) {
    if (typeof value === 'number') {
      return value;
    }
    if (typeof value === 'object' && value !== null) {
      if (Array.isArray(value)) {
        return `Array(${value.length})`;
      }
      return JSON.stringify(value);
    }
    return String(value);
  }

  formatCellValue(value) {
    if (value === null || value === undefined) {
      return 'N/A';
    }
    if (typeof value === 'object') {
      if (value instanceof Date) {
        return value.toLocaleDateString();
      }
      return JSON.stringify(value);
    }
    return value;
  }

  getReportDisplayName(reportType) {
    const displayNames = {
      'user-summary': 'User Summary Report',
      'user-registration': 'User Registration Trends',
      'user-activity': 'User Activity Analysis',
      'job-postings': 'Job Postings Overview',
      'job-performance': 'Job Performance Metrics',
      'employer-activity': 'Employer Activity Report',
      'application-summary': 'Application Summary',
      'application-trends': 'Application Trends Analysis',
      'system-health': 'System Health Report',
      'verification-report': 'Verification Status Report',
      'platform-analytics': 'Platform Analytics',
      'revenue-analytics': 'Revenue Analytics'
    };
    
    return displayNames[reportType] || reportType.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  }
}

module.exports = new XLSXReportService();
