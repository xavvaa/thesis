let XLSX;
try {
  XLSX = require('xlsx');
} catch (error) {
  console.warn('XLSX library not found. Please install it with: npm install xlsx');
  XLSX = null;
}

class XLSXReportService {
  constructor() {
    this.defaultStyles = {
      header: {
        font: { bold: true, color: { rgb: "FFFFFF" } },
        fill: { fgColor: { rgb: "2563EB" } },
        alignment: { horizontal: "center", vertical: "center" }
      },
      subHeader: {
        font: { bold: true, color: { rgb: "374151" } },
        fill: { fgColor: { rgb: "F3F4F6" } },
        alignment: { horizontal: "left", vertical: "center" }
      },
      data: {
        font: { color: { rgb: "374151" } },
        alignment: { horizontal: "left", vertical: "center" }
      },
      number: {
        font: { color: { rgb: "374151" } },
        alignment: { horizontal: "right", vertical: "center" },
        numFmt: "#,##0"
      },
      currency: {
        font: { color: { rgb: "374151" } },
        alignment: { horizontal: "right", vertical: "center" },
        numFmt: "$#,##0.00"
      }
    };
  }

  generateReportXLSX(reportData, reportName = 'Report') {
    if (!XLSX) {
      throw new Error('XLSX library not available. Please install it with: npm install xlsx');
    }
    
    const workbook = XLSX.utils.book_new();
    
    // Create summary sheet
    this.addSummarySheet(workbook, reportData, reportName);
    
    // Create detailed data sheet if available
    if (reportData.data.details && reportData.data.details.length > 0) {
      this.addDetailsSheet(workbook, reportData.data.details, 'Detailed Data');
    }
    
    // Create trends sheet if available
    if (reportData.data.registrationTrends || reportData.data.trends) {
      const trendsData = reportData.data.registrationTrends || reportData.data.trends;
      this.addTrendsSheet(workbook, trendsData, 'Trends Analysis');
    }
    
    // Add metadata sheet
    this.addMetadataSheet(workbook, reportData.reportMetadata);
    
    return XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
  }

  addSummarySheet(workbook, reportData, reportName) {
    const summaryData = [];
    
    // Title row with organization name
    summaryData.push(['PESO - Public Employment Service Office']);
    summaryData.push([reportName]);
    summaryData.push([]); // Empty row
    
    // Report info in two columns
    summaryData.push(['Report Information', '']);
    summaryData.push(['Generated:', new Date(reportData.reportMetadata.generatedAt).toLocaleString()]);
    summaryData.push(['Date Range:', `${reportData.reportMetadata.startDate} to ${reportData.reportMetadata.endDate}`]);
    summaryData.push(['Generated By:', reportData.reportMetadata.generatedBy]);
    summaryData.push(['Format:', reportData.reportMetadata.format.toUpperCase()]);
    summaryData.push([]); // Empty row
    
    // Summary metrics in organized columns
    if (reportData.data.summary) {
      summaryData.push(['Key Metrics', '', '', '']);
      summaryData.push([]); // Empty row
      
      // Organize metrics in 2 columns for better readability
      const entries = Object.entries(reportData.data.summary);
      const midPoint = Math.ceil(entries.length / 2);
      
      summaryData.push(['Metric', 'Value', '', 'Metric', 'Value']);
      
      for (let i = 0; i < midPoint; i++) {
        const [key1, value1] = entries[i];
        const formattedKey1 = this.formatLabel(key1);
        const formattedValue1 = this.formatValue(value1);
        
        if (i + midPoint < entries.length) {
          const [key2, value2] = entries[i + midPoint];
          const formattedKey2 = this.formatLabel(key2);
          const formattedValue2 = this.formatValue(value2);
          summaryData.push([formattedKey1, formattedValue1, '', formattedKey2, formattedValue2]);
        } else {
          summaryData.push([formattedKey1, formattedValue1, '', '', '']);
        }
      }
    }
    
    const worksheet = XLSX.utils.aoa_to_sheet(summaryData);
    
    // Set column widths for better layout
    worksheet['!cols'] = [
      { width: 30 }, // First metric name
      { width: 20 }, // First value
      { width: 3 },  // Spacer
      { width: 30 }, // Second metric name
      { width: 20 }  // Second value
    ];
    
    // Apply basic styling
    this.applyBasicStyling(worksheet, summaryData.length);
    
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Summary');
  }

  addDetailsSheet(workbook, details, sheetName) {
    if (!details || details.length === 0) return;
    
    const headers = Object.keys(details[0]);
    const detailsData = [];
    
    // Add title row with styling
    detailsData.push([sheetName]);
    detailsData.push([]); // Empty row for spacing
    
    // Add headers with formatting
    detailsData.push(headers.map(header => this.formatLabel(header)));
    
    // Add data rows with proper formatting
    details.forEach((row, index) => {
      const dataRow = headers.map(header => {
        const value = this.formatCellValue(row[header]);
        // Add row number as first column for reference
        return value;
      });
      detailsData.push(dataRow);
    });
    
    // Add spacing and summary row at bottom
    detailsData.push([]);
    detailsData.push([`Total Records: ${details.length}`, '', '', `Last Updated: ${new Date().toLocaleDateString()}`]);
    
    const worksheet = XLSX.utils.aoa_to_sheet(detailsData);
    
    // Smart column width calculation with better spacing
    const colWidths = headers.map((header, index) => {
      const headerLength = this.formatLabel(header).length;
      const maxContentLength = Math.max(
        ...details.slice(0, 100).map(row => 
          String(this.formatCellValue(row[header])).length
        )
      );
      // Add padding for better readability
      return {
        width: Math.min(Math.max(headerLength + 2, maxContentLength + 2, 15), 60)
      };
    });
    worksheet['!cols'] = colWidths;
    
    // Set row heights for better spacing
    worksheet['!rows'] = [
      { hpt: 25 }, // Title row
      { hpt: 10 }, // Empty row
      { hpt: 22 }  // Header row
    ];
    
    // Apply styling and freeze panes
    this.applyBasicStyling(worksheet, detailsData.length);
    
    // Freeze header row (row 3 since we have title and empty row)
    worksheet['!freeze'] = { xSplit: 0, ySplit: 3 };
    
    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
  }

  addTrendsSheet(workbook, trends, sheetName) {
    if (!trends || trends.length === 0) return;
    
    const trendsData = [];
    
    // Headers based on trend data structure
    if (trends[0]._id) {
      // Handle aggregated trend data
      trendsData.push(['Date', 'Category', 'Count']);
      
      trends.forEach(trend => {
        let dateStr = '';
        if (trend._id.year && trend._id.month && trend._id.day) {
          dateStr = `${trend._id.year}-${String(trend._id.month).padStart(2, '0')}-${String(trend._id.day).padStart(2, '0')}`;
        } else if (trend._id.year && trend._id.month) {
          dateStr = `${trend._id.year}-${String(trend._id.month).padStart(2, '0')}`;
        }
        
        const category = trend._id.role || trend._id.status || 'N/A';
        trendsData.push([dateStr, category, trend.count]);
      });
    } else {
      // Handle simple array data
      trendsData.push(['Index', 'Value']);
      trends.forEach((item, index) => {
        trendsData.push([index + 1, JSON.stringify(item)]);
      });
    }
    
    const worksheet = XLSX.utils.aoa_to_sheet(trendsData);
    
    // Set column widths
    worksheet['!cols'] = [
      { width: 15 }, // Date
      { width: 20 }, // Category
      { width: 10 }  // Count
    ];
    
    this.applyBasicStyling(worksheet, trendsData.length);
    
    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
  }

  addMetadataSheet(workbook, metadata) {
    const metadataArray = [];
    
    metadataArray.push(['Report Metadata']);
    metadataArray.push([]); // Empty row
    
    Object.entries(metadata).forEach(([key, value]) => {
      const formattedKey = this.formatLabel(key);
      let formattedValue = value;
      
      if (key.includes('Date') && value) {
        formattedValue = new Date(value).toLocaleString();
      } else if (typeof value === 'object') {
        formattedValue = JSON.stringify(value);
      }
      
      metadataArray.push([formattedKey, formattedValue]);
    });
    
    const worksheet = XLSX.utils.aoa_to_sheet(metadataArray);
    
    worksheet['!cols'] = [
      { width: 20 },
      { width: 30 }
    ];
    
    this.applyBasicStyling(worksheet, metadataArray.length);
    
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Metadata');
  }

  generateBulkReportsXLSX(allReportsData) {
    if (!XLSX) {
      throw new Error('XLSX library not available. Please install it with: npm install xlsx');
    }
    
    const workbook = XLSX.utils.book_new();
    
    // Create overview sheet
    this.addOverviewSheet(workbook, allReportsData);
    
    // Create individual sheets for each report
    allReportsData.reports.forEach((report, index) => {
      const reportName = this.getReportDisplayName(report.reportType);
      const sheetName = `${index + 1}. ${reportName}`.substring(0, 31); // Excel sheet name limit
      
      this.addIndividualReportSheet(workbook, report, sheetName);
    });
    
    return XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
  }

  addOverviewSheet(workbook, allReportsData) {
    const overviewData = [];
    
    // Title and organization
    overviewData.push(['PESO - Public Employment Service Office']);
    overviewData.push(['Comprehensive Reports Overview']);
    overviewData.push([]);
    
    // Metadata in organized layout
    overviewData.push(['Report Information', '', 'Statistics', '']);
    overviewData.push(['Generated:', new Date(allReportsData.metadata.generatedAt).toLocaleString(), 'Total Reports:', allReportsData.metadata.totalReports]);
    overviewData.push(['Date Range:', allReportsData.metadata.dateRange, 'Failed Reports:', allReportsData.metadata.failedReports || 0]);
    overviewData.push(['Format:', 'Excel Workbook', 'Success Rate:', `${((1 - (allReportsData.metadata.failedReports || 0) / allReportsData.metadata.totalReports) * 100).toFixed(1)}%`]);
    overviewData.push([]);
    
    // Reports list with enhanced columns
    overviewData.push(['#', 'Report Name', 'Report Type', 'Category', 'Status']);
    
    allReportsData.reports.forEach((report, index) => {
      const reportName = this.getReportDisplayName(report.reportType);
      const category = this.getReportCategory(report.reportType);
      overviewData.push([
        index + 1,
        reportName,
        report.reportType,
        category,
        'âœ“ Generated'
      ]);
    });
    
    // Add summary
    overviewData.push([]);
    overviewData.push(['Summary', '', '', '', '']);
    overviewData.push(['Total Sheets:', allReportsData.reports.length + 1, '', 'Status:', 'Complete']);
    
    const worksheet = XLSX.utils.aoa_to_sheet(overviewData);
    
    worksheet['!cols'] = [
      { width: 5 },  // Index
      { width: 35 }, // Name
      { width: 25 }, // Type
      { width: 20 }, // Category
      { width: 15 }  // Status
    ];
    
    this.applyBasicStyling(worksheet, overviewData.length);
    
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Overview');
  }

  getReportCategory(reportType) {
    const categories = {
      'dashboard-overview': 'Overview',
      'employer-verification': 'Employers',
      'employer-documents': 'Employers',
      'job-postings': 'Jobs',
      'job-demand-analytics': 'Jobs',
      'jobseekers-summary': 'Jobseekers',
      'jobseeker-resumes': 'Jobseekers',
      'compliance-overview': 'Compliance',
      'admin-activity': 'Admin',
      'admin-permissions': 'Admin',
      'system-health': 'System',
      'system-settings': 'System'
    };
    return categories[reportType] || 'General';
  }

  addIndividualReportSheet(workbook, report, sheetName) {
    const reportData = [];
    
    // Report title and metadata
    const reportDisplayName = this.getReportDisplayName(report.reportType);
    reportData.push([reportDisplayName]);
    reportData.push([`Report Type: ${report.reportType}`]);
    reportData.push([]);
    
    // Summary data in organized columns
    if (report.data && report.data.summary) {
      reportData.push(['Executive Summary']);
      reportData.push([]);
      
      const entries = Object.entries(report.data.summary);
      const midPoint = Math.ceil(entries.length / 2);
      
      reportData.push(['Metric', 'Value', '', 'Metric', 'Value']);
      
      for (let i = 0; i < midPoint; i++) {
        const [key1, value1] = entries[i];
        if (i + midPoint < entries.length) {
          const [key2, value2] = entries[i + midPoint];
          reportData.push([
            this.formatLabel(key1), 
            this.formatValue(value1), 
            '', 
            this.formatLabel(key2), 
            this.formatValue(value2)
          ]);
        } else {
          reportData.push([this.formatLabel(key1), this.formatValue(value1), '', '', '']);
        }
      }
      
      reportData.push([]);
      reportData.push([]);
    }
    
    // Detailed data with better organization
    if (report.data && report.data.details && report.data.details.length > 0) {
      const maxRecords = 500; // Increased limit
      reportData.push([`Detailed Data (Showing ${Math.min(report.data.details.length, maxRecords)} of ${report.data.details.length} records)`]);
      reportData.push([]);
      
      const details = report.data.details.slice(0, maxRecords);
      const headers = Object.keys(details[0]);
      
      // Add headers
      reportData.push(headers.map(h => this.formatLabel(h)));
      
      // Add data rows
      details.forEach(row => {
        const dataRow = headers.map(header => this.formatCellValue(row[header]));
        reportData.push(dataRow);
      });
      
      // Add summary footer
      reportData.push([]);
      reportData.push([`Total Records: ${report.data.details.length}`]);
      if (report.data.details.length > maxRecords) {
        reportData.push([`Note: Showing first ${maxRecords} records for performance`]);
      }
    }
    
    const worksheet = XLSX.utils.aoa_to_sheet(reportData);
    
    // Smart column sizing
    const maxCols = Math.max(...reportData.map(row => row.length));
    const colWidths = [];
    for (let i = 0; i < maxCols; i++) {
      const columnData = reportData.map(row => row[i] || '');
      const maxLength = Math.max(...columnData.map(cell => String(cell).length));
      colWidths.push({ width: Math.min(Math.max(maxLength, 12), 50) });
    }
    worksheet['!cols'] = colWidths;
    
    this.applyBasicStyling(worksheet, reportData.length);
    
    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
  }

  applyBasicStyling(worksheet, rowCount) {
    // Note: Basic XLSX.js has limited styling capabilities
    // For advanced styling, consider using exceljs or xlsx-style
    
    // Set row heights for headers
    if (!worksheet['!rows']) worksheet['!rows'] = [];
    
    // Make first row (title) taller
    worksheet['!rows'][0] = { hpt: 25 };
    
    // Auto-filter for data tables (if applicable)
    if (rowCount > 2) {
      const range = XLSX.utils.decode_range(worksheet['!ref']);
      if (range.e.r > 1) {
        worksheet['!autofilter'] = { ref: worksheet['!ref'] };
      }
    }
  }

  formatLabel(key) {
    // Convert camelCase to Title Case with proper spacing
    return key
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .trim();
  }

  formatValue(value) {
    if (typeof value === 'number') {
      return value;
    }
    if (typeof value === 'boolean') {
      return value ? 'Yes' : 'No';
    }
    if (typeof value === 'object' && value !== null) {
      if (Array.isArray(value)) {
        return `${value.length} items`;
      }
      return JSON.stringify(value);
    }
    return String(value);
  }

  formatCellValue(value) {
    if (value === null || value === undefined) {
      return 'N/A';
    }
    if (typeof value === 'boolean') {
      return value ? 'Yes' : 'No';
    }
    if (typeof value === 'number') {
      return value;
    }
    if (typeof value === 'object') {
      if (value instanceof Date) {
        return value.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
      }
      if (Array.isArray(value)) {
        return `${value.length} items`;
      }
      const str = JSON.stringify(value);
      return str.length > 50 ? str.substring(0, 47) + '...' : str;
    }
    const str = String(value);
    return str.length > 100 ? str.substring(0, 97) + '...' : str;
  }

  getReportDisplayName(reportType) {
    const displayNames = {
      'user-summary': 'User Summary Report',
      'user-registration': 'User Registration Trends',
      'user-activity': 'User Activity Analysis',
      'job-postings': 'Job Postings Overview',
      'job-performance': 'Job Performance Metrics',
      'employer-activity': 'Employer Activity Report',
      'application-summary': 'Application Summary',
      'application-trends': 'Application Trends Analysis',
      'system-health': 'System Health Report',
      'verification-report': 'Verification Status Report',
      'platform-analytics': 'Platform Analytics',
      'revenue-analytics': 'Revenue Analytics'
    };
    
    return displayNames[reportType] || reportType.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  }
}

module.exports = new XLSXReportService();
