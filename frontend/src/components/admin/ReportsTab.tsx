import React, { useState, useEffect } from 'react';
import { 
  FiDownload, 
  FiCalendar, 
  FiFilter, 
  FiFileText, 
  FiUsers, 
  FiBriefcase, 
  FiFile,
  FiTrendingUp,
  FiBarChart2,
  FiClock,
} from 'react-icons/fi';
import adminService from '../../services/adminService';
import './ReportsTab.css';

interface ReportFilter {
  reportTypes: string[];
  dateRange: string;
  startDate: string;
  endDate: string;
  format: 'pdf' | 'csv' | 'json' | 'xlsx';
  includeDetails: boolean;
}

interface ReportData {
  id: string;
  name: string;
  description: string;
  icon: React.ComponentType;
  category: 'overview' | 'employers' | 'jobs' | 'jobseekers' | 'compliance' | 'admin' | 'system';
}

// Helper functions for report formatting
const convertToCSV = (reportData: any): string => {
  const { reportMetadata, data } = reportData;
  
  let csvContent = `Report: ${reportMetadata.reportType}\n`;
  csvContent += `Generated: ${new Date(reportMetadata.generatedAt).toLocaleString()}\n`;
  csvContent += `Date Range: ${reportMetadata.startDate} to ${reportMetadata.endDate}\n\n`;
  
  // Add summary data
  if (data.summary) {
    csvContent += "Summary\n";
    Object.entries(data.summary).forEach(([key, value]) => {
      csvContent += `${key},${value}\n`;
    });
    csvContent += "\n";
  }
  
  // Add detailed data if available
  if (data.details && Array.isArray(data.details) && data.details.length > 0) {
    csvContent += "Detailed Data\n";
    const headers = Object.keys(data.details[0]);
    csvContent += headers.join(',') + '\n';
    
    data.details.forEach((item: any) => {
      const row = headers.map(header => {
        const value = item[header];
        return typeof value === 'object' ? JSON.stringify(value) : value;
      });
      csvContent += row.join(',') + '\n';
    });
  }
  
  return csvContent;
};

const formatReportForPDF = (reportData: any, reportName?: string): string => {
  const { reportMetadata, data } = reportData;
  
  let content = `${reportName || 'Report'}\n`;
  content += `${'='.repeat(50)}\n\n`;
  content += `Generated: ${new Date(reportMetadata.generatedAt).toLocaleString()}\n`;
  content += `Date Range: ${reportMetadata.startDate} to ${reportMetadata.endDate}\n`;
  content += `Generated By: ${reportMetadata.generatedBy}\n\n`;
  
  // Add summary
  if (data.summary) {
    content += "SUMMARY\n";
    content += `${'-'.repeat(20)}\n`;
    Object.entries(data.summary).forEach(([key, value]) => {
      content += `${key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}: ${value}\n`;
    });
    content += "\n";
  }
  
  // Add detailed data
  if (data.details && Array.isArray(data.details) && data.details.length > 0) {
    content += "DETAILED DATA\n";
    content += `${'-'.repeat(20)}\n`;
    data.details.forEach((item: any, index: number) => {
      content += `Record ${index + 1}:\n`;
      Object.entries(item).forEach(([key, value]) => {
        content += `  ${key}: ${typeof value === 'object' ? JSON.stringify(value) : value}\n`;
      });
      content += "\n";
    });
  }
  
  return content;
};

const ReportsTab: React.FC = () => {
  const [filters, setFilters] = useState<ReportFilter>({
    reportTypes: [],
    dateRange: 'last30days',
    startDate: '',
    endDate: '',
    format: 'pdf',
    includeDetails: true
  });
  
  const [loading, setLoading] = useState(false);
  const [generatedReports, setGeneratedReports] = useState<any[]>([]);
  const [previewData, setPreviewData] = useState<any>(null);
  const [showPreview, setShowPreview] = useState(false);
  const [notification, setNotification] = useState<{type: 'success' | 'error' | 'info', message: string} | null>(null);
  const [bulkGenerating, setBulkGenerating] = useState(false);
  const [bulkProgress, setBulkProgress] = useState<{current: number, total: number, currentReport: string}>({current: 0, total: 0, currentReport: ''});

  const reportTypes: ReportData[] = [
    // Overview Dashboard Reports
    {
      id: 'dashboard-overview',
      name: 'Dashboard Overview Report',
      description: 'Complete overview with key metrics, user counts, and system status',
      icon: FiTrendingUp,
      category: 'overview'
    },
    
    // Employer Verification Reports
    {
      id: 'employer-verification',
      name: 'Employer Verification Report',
      description: 'Employer verification status, pending approvals, and document compliance',
      icon: FiFileText,
      category: 'employers'
    },
    {
      id: 'employer-documents',
      name: 'Employer Documents Report',
      description: 'Document verification status, approval rates, and compliance tracking',
      icon: FiFile,
      category: 'employers'
    },
    
    // Job Postings Reports
    {
      id: 'job-postings',
      name: 'Job Postings Report',
      description: 'All job postings with status, employer info, and performance metrics',
      icon: FiBriefcase,
      category: 'jobs'
    },
    {
      id: 'job-demand-analytics',
      name: 'Job Demand Analytics Report',
      description: 'Job market demand, skills analytics, and competition analysis',
      icon: FiBarChart2,
      category: 'jobs'
    },
    
    // Jobseekers Reports
    {
      id: 'jobseekers-summary',
      name: 'Jobseekers Summary Report',
      description: 'Job seeker profiles, activity, and application patterns',
      icon: FiUsers,
      category: 'jobseekers'
    },
    {
      id: 'jobseeker-resumes',
      name: 'Resume Analytics Report',
      description: 'Resume submissions, skills distribution, and profile completeness',
      icon: FiFileText,
      category: 'jobseekers'
    },
    
    // Compliance Reports
    {
      id: 'compliance-overview',
      name: 'Compliance Overview Report',
      description: 'System compliance status, regulatory adherence, and audit trails',
      icon: FiFileText,
      category: 'compliance'
    },
    
    // Admin Management Reports (Super Admin Only)
    {
      id: 'admin-activity',
      name: 'Admin Activity Report',
      description: 'Administrator actions, login patterns, and system access logs',
      icon: FiUsers,
      category: 'admin'
    },
    {
      id: 'admin-permissions',
      name: 'Admin Permissions Report',
      description: 'Administrator roles, permissions, and access control audit',
      icon: FiFileText,
      category: 'admin'
    },
    
    // System Settings & Health Reports
    {
      id: 'system-health',
      name: 'System Health Report',
      description: 'Server performance, database metrics, and system uptime',
      icon: FiBarChart2,
      category: 'system'
    },
    {
      id: 'system-settings',
      name: 'System Configuration Report',
      description: 'Current system settings, configurations, and security status',
      icon: FiFileText,
      category: 'system'
    }
  ];

  const dateRangeOptions = [
    // Quick ranges
    { value: 'today', label: 'Today' },
    { value: 'yesterday', label: 'Yesterday' },
    
    // Weekly/Monthly ranges
    { value: 'last7days', label: 'Last 7 Days' },
    { value: 'last30days', label: 'Last 30 Days' },
    
    // Current periods
    { value: 'thisweek', label: 'This Week' },
    { value: 'thismonth', label: 'This Month' },
    { value: 'thisquarter', label: 'This Quarter' },
    { value: 'thisyear', label: 'This Year' },
    
    // Previous periods
    { value: 'lastweek', label: 'Last Week' },
    { value: 'lastmonth', label: 'Last Month' },
    { value: 'lastquarter', label: 'Last Quarter' },
    { value: 'lastyear', label: 'Last Year' },
    
    // Extended ranges
    { value: 'last3months', label: 'Last 3 Months' },
    { value: 'last6months', label: 'Last 6 Months' },
    
    // Custom
    { value: 'custom', label: 'Custom Range' }
  ];

  const formatOptions = [
    { value: 'pdf', label: 'PDF Document' },
    { value: 'csv', label: 'CSV Spreadsheet' },
    { value: 'xlsx', label: 'Excel Spreadsheet' },
    { value: 'json', label: 'JSON Data' }
  ];

  useEffect(() => {
    // Set default date range based on selection
    const today = new Date();
    const formatDate = (date: Date) => date.toISOString().split('T')[0];

    switch (filters.dateRange) {
      case 'today':
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(today),
          endDate: formatDate(today)
        }));
        break;
        
      case 'yesterday':
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(yesterday),
          endDate: formatDate(yesterday)
        }));
        break;
        
      case 'last7days':
        const week = new Date(today);
        week.setDate(week.getDate() - 7);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(week),
          endDate: formatDate(today)
        }));
        break;
        
      case 'last30days':
        const month = new Date(today);
        month.setDate(month.getDate() - 30);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(month),
          endDate: formatDate(today)
        }));
        break;
        
      case 'thisweek':
        const startOfWeek = new Date(today);
        const day = startOfWeek.getDay();
        const diff = startOfWeek.getDate() - day + (day === 0 ? -6 : 1); // Monday as first day
        startOfWeek.setDate(diff);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(startOfWeek),
          endDate: formatDate(today)
        }));
        break;
        
      case 'thismonth':
        const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(startOfMonth),
          endDate: formatDate(today)
        }));
        break;
        
      case 'thisquarter':
        const quarterStart = new Date(today.getFullYear(), Math.floor(today.getMonth() / 3) * 3, 1);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(quarterStart),
          endDate: formatDate(today)
        }));
        break;
        
      case 'thisyear':
        const startOfYear = new Date(today.getFullYear(), 0, 1);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(startOfYear),
          endDate: formatDate(today)
        }));
        break;
        
      case 'lastweek':
        const lastWeekEnd = new Date(today);
        const lastWeekStart = new Date(today);
        const dayOfWeek = lastWeekEnd.getDay();
        const daysToSubtract = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Monday as first day
        lastWeekEnd.setDate(lastWeekEnd.getDate() - daysToSubtract - 1);
        lastWeekStart.setDate(lastWeekEnd.getDate() - 6);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(lastWeekStart),
          endDate: formatDate(lastWeekEnd)
        }));
        break;
        
      case 'lastmonth':
        const lastMonthStart = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        const lastMonthEnd = new Date(today.getFullYear(), today.getMonth(), 0);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(lastMonthStart),
          endDate: formatDate(lastMonthEnd)
        }));
        break;
        
      case 'lastquarter':
        const currentQuarter = Math.floor(today.getMonth() / 3);
        const lastQuarterStart = new Date(today.getFullYear(), (currentQuarter - 1) * 3, 1);
        const lastQuarterEnd = new Date(today.getFullYear(), currentQuarter * 3, 0);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(lastQuarterStart),
          endDate: formatDate(lastQuarterEnd)
        }));
        break;
        
      case 'lastyear':
        const lastYearStart = new Date(today.getFullYear() - 1, 0, 1);
        const lastYearEnd = new Date(today.getFullYear() - 1, 11, 31);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(lastYearStart),
          endDate: formatDate(lastYearEnd)
        }));
        break;
        
      case 'last3months':
        const threeMonthsAgo = new Date(today);
        threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(threeMonthsAgo),
          endDate: formatDate(today)
        }));
        break;
        
      case 'last6months':
        const sixMonthsAgo = new Date(today);
        sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(sixMonthsAgo),
          endDate: formatDate(today)
        }));
        break;
    }
  }, [filters.dateRange]);

  const handleGenerateReport = async () => {
    if (filters.reportTypes.length === 0) {
      setNotification({type: 'error', message: 'Please select at least one report type'});
      return;
    }

    setLoading(true);
    try {
      console.log('Generating reports with filters:', filters);
      
      if (filters.reportTypes.length === 1) {
        // Single report generation
        const reportType = filters.reportTypes[0];
        const selectedReport = reportTypes.find(r => r.id === reportType);
        const fileName = `${selectedReport?.name || 'Report'}_${filters.startDate}_to_${filters.endDate}.${filters.format}`;
        
        if (filters.format === 'pdf' || filters.format === 'xlsx') {
          // For PDF/XLSX, make a direct request to get the binary data
          const response = await fetch('http://localhost:3001/api/admin/reports/generate', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${localStorage.getItem('adminToken')}`
            },
            body: JSON.stringify({
              reportType: reportType,
              startDate: filters.startDate,
              endDate: filters.endDate,
              format: filters.format,
              includeDetails: filters.includeDetails
            })
          });

          if (!response.ok) {
            throw new Error(`Failed to generate ${filters.format.toUpperCase()} report`);
          }

          // Check if response is binary or JSON (fallback)
          const contentType = response.headers.get('Content-Type');
          
          if (contentType && (contentType.includes('application/pdf') || contentType.includes('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'))) {
            // Handle binary response (PDF/XLSX)
            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(url);
          } else {
            // Handle JSON fallback
            const data = await response.json();
            if (data.pdfError || data.xlsxError) {
              console.warn(`${filters.format.toUpperCase()} generation failed, falling back to text format:`, data.pdfError || data.xlsxError);
              const textContent = formatReportForPDF(data.report, selectedReport?.name);
              const blob = new Blob([textContent], { type: 'text/plain' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = fileName.replace(/\.(pdf|xlsx)$/, '.txt');
              a.click();
              URL.revokeObjectURL(url);
            }
          }
        } else {
          // For JSON and CSV, use the existing service method
          const reportData = await adminService.generateReport({
            reportType: reportType,
            startDate: filters.startDate,
            endDate: filters.endDate,
            format: filters.format,
            includeDetails: filters.includeDetails
          });

          if (filters.format === 'json') {
            const blob = new Blob([JSON.stringify(reportData.report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(url);
          } else if (filters.format === 'csv') {
            const csvContent = convertToCSV(reportData.report);
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(url);
          }
        }

        // Add to generated reports list
        const newReport = {
          id: Date.now().toString(),
          name: selectedReport?.name || 'Report',
          type: reportType,
          dateRange: `${filters.startDate} to ${filters.endDate}`,
          format: filters.format,
          generatedAt: new Date().toISOString(),
          size: '2.3 MB'
        };
        
        setGeneratedReports(prev => [newReport, ...prev]);
        setNotification({type: 'success', message: `${selectedReport?.name} generated successfully!`});
      } else {
        // Multiple reports generation - use bulk generation
        await handleGenerateSelectedReports();
        return;
      }
      
      // Auto-hide notification after 3 seconds
      setTimeout(() => setNotification(null), 3000);
    } catch (error) {
      console.error('Error generating report:', error);
      setNotification({type: 'error', message: `Failed to generate report: ${error.message}`});
      
      // Auto-hide notification after 5 seconds
      setTimeout(() => setNotification(null), 5000);
    } finally {
      setLoading(false);
    }
  };

  const handleGenerateSelectedReports = async () => {
    setBulkGenerating(true);
    setBulkProgress({current: 0, total: filters.reportTypes.length, currentReport: 'Initializing...'});
    
    try {
      setNotification({type: 'info', message: `Starting generation of ${filters.reportTypes.length} selected reports...`});
      
      // Generate reports for selected types only
      const fileName = `Selected_Reports_${filters.startDate}_to_${filters.endDate}.${filters.format}`;
      
      if (filters.format === 'pdf' || filters.format === 'xlsx') {
        // For PDF/XLSX, make a direct request to get the binary data
        const response = await fetch('http://localhost:3001/api/admin/reports/generate-selected', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('adminToken')}`
          },
          body: JSON.stringify({
            reportTypes: filters.reportTypes,
            startDate: filters.startDate,
            endDate: filters.endDate,
            format: filters.format,
            includeDetails: filters.includeDetails
          })
        });

        setBulkProgress({current: filters.reportTypes.length, total: filters.reportTypes.length, currentReport: 'Completing...'});

        if (!response.ok) {
          throw new Error(`Failed to generate selected ${filters.format.toUpperCase()} reports`);
        }

        // Check if response is binary or JSON (fallback)
        const contentType = response.headers.get('Content-Type');
        
        if (contentType && (contentType.includes('application/pdf') || contentType.includes('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'))) {
          // Handle binary response (PDF/XLSX)
          const blob = await response.blob();
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName;
          a.click();
          URL.revokeObjectURL(url);
        } else {
          // Handle JSON fallback
          const data = await response.json();
          if (data.pdfError || data.xlsxError) {
            console.warn(`Selected ${filters.format.toUpperCase()} generation failed, falling back to text format:`, data.pdfError || data.xlsxError);
            let textContent = `SELECTED REPORTS SUMMARY\n${'='.repeat(50)}\n\n`;
            textContent += `Generated: ${new Date().toLocaleString()}\n`;
            textContent += `Selected Reports: ${filters.reportTypes.length}\n\n`;
            
            const blob = new Blob([textContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName.replace(/\.(pdf|xlsx)$/, '.txt');
            a.click();
            URL.revokeObjectURL(url);
          }
        }
      }

      setNotification({type: 'success', message: `${filters.reportTypes.length} selected reports generated successfully! ðŸŽ‰`});
      setTimeout(() => setNotification(null), 5000);

    } catch (error) {
      console.error('Selected reports generation error:', error);
      setNotification({type: 'error', message: `Selected reports generation failed: ${error.message}`});
      setTimeout(() => setNotification(null), 5000);
    } finally {
      setBulkGenerating(false);
      setBulkProgress({current: 0, total: 0, currentReport: ''});
    }
  };

  const getCategoryReports = (category: string) => {
    return reportTypes.filter(report => report.category === category);
  };

  const categories = [
    { id: 'overview', name: 'Dashboard Overview', icon: FiTrendingUp },
    { id: 'employers', name: 'Employer Reports', icon: FiBriefcase },
    { id: 'jobs', name: 'Job Reports', icon: FiFile },
    { id: 'jobseekers', name: 'Jobseeker Reports', icon: FiUsers },
    { id: 'compliance', name: 'Compliance Reports', icon: FiFileText },
    { id: 'admin', name: 'Admin Reports', icon: FiBarChart2 },
    { id: 'system', name: 'System Reports', icon: FiBarChart2 }
  ];

  const handlePreviewReport = async () => {
    if (filters.reportTypes.length === 0) {
      setNotification({type: 'error', message: 'Please select at least one report type first'});
      return;
    }

    setLoading(true);
    try {
      if (filters.reportTypes.length === 1) {
        // Single report preview
        const reportType = filters.reportTypes[0];
        const previewFilters = {
          reportType: reportType,
          startDate: filters.startDate,
          endDate: filters.endDate,
          format: 'json' as 'json', // Always use JSON format for preview to ensure parseable response
          includeDetails: false // Preview without detailed data
        };
        
        const reportData = await adminService.generateReport(previewFilters);
        setPreviewData(reportData.report);
        setShowPreview(true);
        
        const selectedReport = reportTypes.find(r => r.id === reportType);
        setNotification({type: 'info', message: `Preview generated for "${selectedReport?.name}"`});
      } else {
        // Multiple reports preview - generate all and combine
        const previewPromises = filters.reportTypes.map(async (reportType) => {
          const previewFilters = {
            reportType: reportType,
            startDate: filters.startDate,
            endDate: filters.endDate,
            format: 'json' as 'json',
            includeDetails: false
          };
          
          try {
            const reportData = await adminService.generateReport(previewFilters);
            const reportInfo = reportTypes.find(r => r.id === reportType);
            return {
              reportType: reportType,
              reportName: reportInfo?.name || reportType,
              data: reportData.report
            };
          } catch (error) {
            console.error(`Error generating preview for ${reportType}:`, error);
            return {
              reportType: reportType,
              reportName: reportTypes.find(r => r.id === reportType)?.name || reportType,
              error: error.message
            };
          }
        });

        const allReports = await Promise.all(previewPromises);
        
        // Create combined preview data
        const combinedPreview = {
          reportMetadata: {
            reportType: `Multiple Reports (${filters.reportTypes.length})`,
            startDate: filters.startDate,
            endDate: filters.endDate,
            generatedAt: new Date().toISOString(),
            selectedReports: filters.reportTypes.length
          },
          data: {
            summary: {
              totalReportsSelected: filters.reportTypes.length,
              successfulPreviews: allReports.filter(r => !r.error).length,
              failedPreviews: allReports.filter(r => r.error).length
            }
          },
          multipleReports: allReports
        };

        setPreviewData(combinedPreview);
        setShowPreview(true);
        
        const successCount = allReports.filter(r => !r.error).length;
        const message = `Preview generated for ${successCount} of ${filters.reportTypes.length} selected reports`;
        setNotification({type: 'info', message});
      }
      
      setTimeout(() => setNotification(null), 3000);
    } catch (error) {
      console.error('Error generating preview:', error);
      setNotification({type: 'error', message: `Failed to generate preview: ${error.message}`});
      setTimeout(() => setNotification(null), 5000);
    } finally {
      setLoading(false);
    }
  };

  const isFormValid = () => {
    return filters.reportTypes.length > 0 && filters.startDate && filters.endDate;
  };

  const handleSelectAll = () => {
    setFilters(prev => ({ ...prev, reportTypes: reportTypes.map(r => r.id) }));
  };

  const handleClearAll = () => {
    setFilters(prev => ({ ...prev, reportTypes: [] }));
  };

  const handleToggleReport = (reportId: string) => {
    setFilters(prev => ({
      ...prev,
      reportTypes: prev.reportTypes.includes(reportId)
        ? prev.reportTypes.filter(id => id !== reportId)
        : [...prev.reportTypes, reportId]
    }));
  };

  const handleGenerateAllReports = async () => {
    if (!filters.startDate || !filters.endDate) {
      setNotification({type: 'error', message: 'Please set date range first'});
      return;
    }

    setBulkGenerating(true);
    setBulkProgress({current: 0, total: reportTypes.length, currentReport: 'Initializing...'});
    
    try {
      setNotification({type: 'info', message: `Starting bulk generation of ${reportTypes.length} reports...`});
      
      // Simulate progress updates
      const progressInterval = setInterval(() => {
        setBulkProgress(prev => {
          if (prev.current < prev.total - 1) {
            const nextIndex = prev.current + 1;
            return {
              ...prev,
              current: nextIndex,
              currentReport: reportTypes[nextIndex]?.name || 'Processing...'
            };
          }
          return prev;
        });
      }, 800);

      const fileName = `All_Reports_${filters.startDate}_to_${filters.endDate}.${filters.format}`;
      
      if (filters.format === 'pdf' || filters.format === 'xlsx') {
        // For PDF/XLSX, make a direct request to get the binary data
        const response = await fetch('http://localhost:3001/api/admin/reports/generate-all', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('adminToken')}`
          },
          body: JSON.stringify({
            startDate: filters.startDate,
            endDate: filters.endDate,
            format: filters.format,
            includeDetails: filters.includeDetails
          })
        });

        clearInterval(progressInterval);
        setBulkProgress({current: reportTypes.length, total: reportTypes.length, currentReport: 'Completing...'});

        if (!response.ok) {
          throw new Error(`Failed to generate bulk ${filters.format.toUpperCase()} reports`);
        }

        // Check if response is binary or JSON (fallback)
        const contentType = response.headers.get('Content-Type');
        
        if (contentType && (contentType.includes('application/pdf') || contentType.includes('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'))) {
          // Handle binary response (PDF/XLSX)
          const blob = await response.blob();
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName;
          a.click();
          URL.revokeObjectURL(url);
        } else {
          // Handle JSON fallback
          const data = await response.json();
          if (data.pdfError || data.xlsxError) {
            console.warn(`Bulk ${filters.format.toUpperCase()} generation failed, falling back to text format:`, data.pdfError || data.xlsxError);
            let textContent = `ALL REPORTS SUMMARY\n${'='.repeat(50)}\n\n`;
            textContent += `Generated: ${new Date(data.data.metadata.generatedAt).toLocaleString()}\n`;
            textContent += `Date Range: ${data.data.metadata.dateRange}\n`;
            textContent += `Total Reports: ${data.data.metadata.totalReports}\n\n`;
            
            data.data.reports.forEach((report: any) => {
              textContent += `\n${report.reportType.toUpperCase()}\n${'-'.repeat(30)}\n`;
              if (report.data.summary) {
                Object.entries(report.data.summary).forEach(([key, value]) => {
                  textContent += `${key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}: ${value}\n`;
                });
              }
              textContent += '\n';
            });
            
            const blob = new Blob([textContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName.replace('.pdf', '.txt');
            a.click();
            URL.revokeObjectURL(url);
          }
        }
      } else {
        // For JSON and CSV, use the existing service method
        const response = await adminService.generateAllReports({
          startDate: filters.startDate,
          endDate: filters.endDate,
          format: filters.format,
          includeDetails: filters.includeDetails
        });

        clearInterval(progressInterval);
        setBulkProgress({current: reportTypes.length, total: reportTypes.length, currentReport: 'Completing...'});

        const { data } = response;
        
        if (filters.format === 'json') {
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName;
          a.click();
          URL.revokeObjectURL(url);
        } else if (filters.format === 'csv') {
          // Convert all reports to CSV
          let csvContent = `All Reports - ${data.metadata.dateRange}\n`;
          csvContent += `Generated: ${new Date(data.metadata.generatedAt).toLocaleString()}\n\n`;
          
          data.reports.forEach((report: any) => {
            csvContent += `\n=== ${report.reportType.toUpperCase()} ===\n`;
            if (report.data.summary) {
              Object.entries(report.data.summary).forEach(([key, value]) => {
                csvContent += `${key},${value}\n`;
              });
            }
          });
          
          const blob = new Blob([csvContent], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName;
          a.click();
          URL.revokeObjectURL(url);
        }
      }

      // Add all reports to the generated reports list (for non-binary formats)
      let successMessage = 'All reports generated successfully! ðŸŽ‰';
      
      if (filters.format !== 'pdf' && filters.format !== 'xlsx') {
        const metadataResponse = await adminService.generateAllReports({
          startDate: filters.startDate,
          endDate: filters.endDate,
          format: 'json', // Get metadata
          includeDetails: false
        });
        
        const newReports = metadataResponse.data.reports.map((report: any, index: number) => ({
          id: `${Date.now()}-${index}`,
          name: reportTypes.find(r => r.id === report.reportType)?.name || report.reportType,
          type: report.reportType,
          dateRange: `${filters.startDate} to ${filters.endDate}`,
          format: filters.format,
          generatedAt: new Date().toISOString(),
          size: '2.3 MB'
        }));
        
        setGeneratedReports(prev => [...newReports, ...prev]);
        
        successMessage = metadataResponse.data.failedReports?.length > 0 
          ? `Generated ${metadataResponse.data.metadata.totalReports} reports successfully. ${metadataResponse.data.failedReports.length} failed.`
          : `All ${metadataResponse.data.metadata.totalReports} reports generated successfully! ðŸŽ‰`;
      }
      
      setNotification({type: 'success', message: successMessage});
      setTimeout(() => setNotification(null), 5000);

    } catch (error) {
      console.error('Bulk generation error:', error);
      setNotification({type: 'error', message: `Bulk generation failed: ${error.message}`});
      setTimeout(() => setNotification(null), 5000);
    } finally {
      setBulkGenerating(false);
      setBulkProgress({current: 0, total: 0, currentReport: ''});
    }
  };

  return (
    <>
      {/* Notification System */}
      {notification && (
        <div className={`notification ${notification.type}`}>
          <div className="notification-content">
            <span>{notification.message}</span>
            <button 
              className="notification-close"
              onClick={() => setNotification(null)}
            >
              Ã—
            </button>
          </div>
        </div>
      )}

      {/* Bulk Generation Progress */}
      {bulkGenerating && (
        <div className="bulk-progress">
          <h3>Generating Reports...</h3>
          <div className="progress-bar">
            <div 
              className="progress-fill"
              style={{ width: `${(bulkProgress.current / bulkProgress.total) * 100}%` }}
            ></div>
          </div>
          <p className="current-report">
            {bulkProgress.currentReport && `Currently generating: ${bulkProgress.currentReport}`}
          </p>
        </div>
      )}

      {/* Reports Management Container - Exactly Like Jobseekers */}
      <div className="reports-management-container">
        {/* Header Container */}
        <div className="reports-header-container">
          <div className="header-left">
            <h2 className="section-title">Reports ({reportTypes.length} total)</h2>
            <p className="view-info">Showing 1-{reportTypes.length} of {reportTypes.length} reports â€¢ {filters.reportTypes.length} selected</p>
          </div>
          
          <div className="reports-controls">
              {/* Date Range Controls */}
              <div className="control-group">
                <select 
                  value={filters.dateRange} 
                  onChange={(e) => setFilters(prev => ({ ...prev, dateRange: e.target.value }))}
                  className="control-select"
                >
                  {dateRangeOptions.map(option => (
                    <option key={option.value} value={option.value}>
                      {option.label}
                    </option>
                  ))}
                </select>
              </div>

              {filters.dateRange === 'custom' && (
                <>
                  <div className="control-group">
                    <input
                      type="date"
                      value={filters.startDate}
                      onChange={(e) => setFilters(prev => ({ ...prev, startDate: e.target.value }))}
                      className="control-input"
                      placeholder="Start Date"
                    />
                  </div>
                  <div className="control-group">
                    <input
                      type="date"
                      value={filters.endDate}
                      onChange={(e) => setFilters(prev => ({ ...prev, endDate: e.target.value }))}
                      className="control-input"
                      placeholder="End Date"
                    />
                  </div>
                </>
              )}

              {/* Format Controls */}
              <div className="control-group">
                <select 
                  value={filters.format} 
                  onChange={(e) => setFilters(prev => ({ ...prev, format: e.target.value as 'pdf' | 'csv' | 'json' | 'xlsx' }))}
                  className="control-select"
                >
                  {formatOptions.map(option => (
                    <option key={option.value} value={option.value}>
                      {option.label}
                    </option>
                  ))}
                </select>
              </div>

              {/* Details Toggle */}
              <div className="control-group">
                <label className="control-checkbox">
                  <input
                    type="checkbox"
                    checked={filters.includeDetails}
                    onChange={(e) => setFilters(prev => ({ ...prev, includeDetails: e.target.checked }))}
                  />
                  <span>Include Details</span>
                </label>
              </div>

              {/* Action Buttons */}
              <div className="control-group">
                <button 
                  onClick={handleSelectAll}
                  className="control-btn control-btn-outline"
                  disabled={filters.reportTypes.length === reportTypes.length}
                >
                  Select All
                </button>
              </div>

              <div className="control-group">
                <button 
                  onClick={handleClearAll}
                  className="control-btn control-btn-outline"
                  disabled={filters.reportTypes.length === 0}
                >
                  Clear All
                </button>
              </div>

              <div className="control-group">
                <button 
                  onClick={handlePreviewReport}
                  disabled={loading || !isFormValid()}
                  className="control-btn control-btn-secondary"
                >
                  {loading ? <FiClock className="spinning" /> : <FiFileText />}
                  Preview
                </button>
              </div>
              
              <div className="control-group">
                <button 
                  onClick={handleGenerateReport}
                  disabled={loading || !isFormValid()}
                  className="control-btn control-btn-primary"
                >
                  {loading ? <FiClock className="spinning" /> : <FiDownload />}
                  Generate
                </button>
              </div>
            </div>
        </div>

        {/* Table Section */}
        {reportTypes.length > 0 ? (
          <div className="admin-reports-table-container">
            <div className="admin-reports-table-wrapper">
              <table className="admin-reports-table">
            <thead>
              <tr>
                <th className="checkbox-column">
                  <input
                    type="checkbox"
                    checked={filters.reportTypes.length === reportTypes.length}
                    onChange={filters.reportTypes.length === reportTypes.length ? handleClearAll : handleSelectAll}
                    className="header-checkbox"
                  />
                </th>
                <th>CATEGORY</th>
                <th>REPORT NAME</th>
                <th>DESCRIPTION</th>
              </tr>
            </thead>
            <tbody>
              {categories.map(category => {
                const categoryReports = getCategoryReports(category.id);
                const CategoryIcon = category.icon;
                
                return categoryReports.map((report, index) => {
                  const ReportIcon = report.icon;
                  const isSelected = filters.reportTypes.includes(report.id);
                  
                  return (
                    <tr 
                      key={report.id}
                      className={`report-row ${isSelected ? 'selected' : ''}`}
                    >
                      <td className="checkbox-cell">
                        <label className="checkbox-wrapper">
                          <input
                            type="checkbox"
                            checked={isSelected}
                            onChange={() => handleToggleReport(report.id)}
                            className="row-checkbox"
                          />
                          <span className="checkbox-clickarea"></span>
                        </label>
                      </td>
                      {index === 0 && (
                        <td 
                          className="category-cell"
                          rowSpan={categoryReports.length}
                        >
                          <div className="category-info">
                            <span className="category-name">{category.name}</span>
                          </div>
                        </td>
                      )}
                      <td 
                        className="report-name-cell"
                        onClick={() => handleToggleReport(report.id)}
                      >
                        <div className="report-name-info">
                          <span className="report-name">{report.name}</span>
                        </div>
                      </td>
                      <td 
                        className="report-description-cell"
                        onClick={() => handleToggleReport(report.id)}
                      >
                        <span className="report-description">{report.description}</span>
                      </td>
                    </tr>
                  );
                });
              })}
            </tbody>
            </table>
          </div>
        </div>
        ) : (
          <div className="no-reports">
            <p>No reports available</p>
          </div>
        )}
      </div>

      {/* Report Preview Modal */}
      {showPreview && previewData && (
        <div className="preview-modal">
          <div className="preview-content">
            <div className="preview-header">
              <h3>Report Preview</h3>
              <button 
                className="close-preview"
                onClick={() => setShowPreview(false)}
              >
                Ã—
              </button>
            </div>
            <div className="preview-body">
              <div className="preview-metadata">
                <h4>Report Information</h4>
                <p><strong>Type:</strong> {previewData.reportMetadata?.reportType}</p>
                <p><strong>Date Range:</strong> {previewData.reportMetadata?.startDate} to {previewData.reportMetadata?.endDate}</p>
                <p><strong>Generated:</strong> {new Date(previewData.reportMetadata?.generatedAt).toLocaleString()}</p>
                {previewData.reportMetadata?.selectedReports && (
                  <p><strong>Selected Reports:</strong> {previewData.reportMetadata.selectedReports}</p>
                )}
              </div>
              
              {previewData.data?.summary && (
                <div className="preview-summary">
                  <h4>Summary Data</h4>
                  <div className="summary-grid">
                    {Object.entries(previewData.data.summary).map(([key, value]) => (
                      <div key={key} className="summary-item">
                        <span className="summary-label">{key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}:</span>
                        <span className="summary-value">{String(value)}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Multiple Reports Display */}
              {previewData.multipleReports && (
                <div className="multiple-reports-preview">
                  <h4>Individual Report Previews</h4>
                  <div className="reports-accordion">
                    {previewData.multipleReports.map((report: any, index: number) => (
                      <div key={report.reportType} className="report-accordion-item">
                        <div className="report-accordion-header">
                          <h5>
                            {index + 1}. {report.reportName}
                            {report.error && <span className="error-badge">Failed</span>}
                          </h5>
                        </div>
                        <div className="report-accordion-content">
                          {report.error ? (
                            <div className="error-message">
                              <p><strong>Error:</strong> {report.error}</p>
                            </div>
                          ) : (
                            report.data?.data?.summary && (
                              <div className="individual-summary">
                                <div className="summary-grid">
                                  {Object.entries(report.data.data.summary).map(([key, value]) => (
                                    <div key={key} className="summary-item">
                                      <span className="summary-label">{key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}:</span>
                                      <span className="summary-value">{String(value)}</span>
                                    </div>
                                  ))}
                                </div>
                              </div>
                            )
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}
              
              <div className="preview-actions">
                <button 
                  onClick={() => {
                    setShowPreview(false);
                    handleGenerateReport();
                  }}
                  className="generate-from-preview-btn"
                >
                  <FiDownload /> Generate Full Report{previewData.multipleReports ? 's' : ''}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Generated Reports History */}
      {generatedReports.length > 0 && (
        <div className="generated-reports">
          <h3><FiCalendar /> Recent Reports ({generatedReports.length})</h3>
          <div className="reports-list">
            {generatedReports.map(report => (
              <div key={report.id} className="report-item">
                <div className="report-details">
                  <h4>{report.name}</h4>
                  <p>Generated: {new Date(report.generatedAt).toLocaleString()}</p>
                  <p>Date Range: {report.dateRange}</p>
                  <span className="report-format">{report.format.toUpperCase()}</span>
                </div>
                <div className="report-actions">
                  <button className="download-btn">
                    <FiDownload /> Re-download
                  </button>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </>
  );
};

export default ReportsTab;
