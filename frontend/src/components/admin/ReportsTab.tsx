import React, { useState, useEffect } from 'react';
import { 
  FiDownload, 
  FiCalendar, 
  FiFilter, 
  FiFileText, 
  FiUsers, 
  FiBriefcase, 
  FiFile,
  FiTrendingUp,
  FiBarChart2,
  FiClock,
} from 'react-icons/fi';
import adminService from '../../services/adminService';
import './ReportsTab.css';

interface ReportFilter {
  reportType: string;
  dateRange: string;
  startDate: string;
  endDate: string;
  format: 'pdf' | 'csv' | 'json';
  includeDetails: boolean;
}

interface ReportData {
  id: string;
  name: string;
  description: string;
  icon: React.ComponentType;
  category: 'users' | 'jobs' | 'applications' | 'system' | 'analytics';
}

// Helper functions for report formatting
const convertToCSV = (reportData: any): string => {
  const { reportMetadata, data } = reportData;
  
  let csvContent = `Report: ${reportMetadata.reportType}\n`;
  csvContent += `Generated: ${new Date(reportMetadata.generatedAt).toLocaleString()}\n`;
  csvContent += `Date Range: ${reportMetadata.startDate} to ${reportMetadata.endDate}\n\n`;
  
  // Add summary data
  if (data.summary) {
    csvContent += "Summary\n";
    Object.entries(data.summary).forEach(([key, value]) => {
      csvContent += `${key},${value}\n`;
    });
    csvContent += "\n";
  }
  
  // Add detailed data if available
  if (data.details && Array.isArray(data.details) && data.details.length > 0) {
    csvContent += "Detailed Data\n";
    const headers = Object.keys(data.details[0]);
    csvContent += headers.join(',') + '\n';
    
    data.details.forEach((item: any) => {
      const row = headers.map(header => {
        const value = item[header];
        return typeof value === 'object' ? JSON.stringify(value) : value;
      });
      csvContent += row.join(',') + '\n';
    });
  }
  
  return csvContent;
};

const formatReportForPDF = (reportData: any, reportName?: string): string => {
  const { reportMetadata, data } = reportData;
  
  let content = `${reportName || 'Report'}\n`;
  content += `${'='.repeat(50)}\n\n`;
  content += `Generated: ${new Date(reportMetadata.generatedAt).toLocaleString()}\n`;
  content += `Date Range: ${reportMetadata.startDate} to ${reportMetadata.endDate}\n`;
  content += `Generated By: ${reportMetadata.generatedBy}\n\n`;
  
  // Add summary
  if (data.summary) {
    content += "SUMMARY\n";
    content += `${'-'.repeat(20)}\n`;
    Object.entries(data.summary).forEach(([key, value]) => {
      content += `${key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}: ${value}\n`;
    });
    content += "\n";
  }
  
  // Add detailed data
  if (data.details && Array.isArray(data.details) && data.details.length > 0) {
    content += "DETAILED DATA\n";
    content += `${'-'.repeat(20)}\n`;
    data.details.forEach((item: any, index: number) => {
      content += `Record ${index + 1}:\n`;
      Object.entries(item).forEach(([key, value]) => {
        content += `  ${key}: ${typeof value === 'object' ? JSON.stringify(value) : value}\n`;
      });
      content += "\n";
    });
  }
  
  return content;
};

const ReportsTab: React.FC = () => {
  const [filters, setFilters] = useState<ReportFilter>({
    reportType: '',
    dateRange: 'last30days',
    startDate: '',
    endDate: '',
    format: 'pdf',
    includeDetails: true
  });
  
  const [loading, setLoading] = useState(false);
  const [generatedReports, setGeneratedReports] = useState<any[]>([]);
  const [previewData, setPreviewData] = useState<any>(null);
  const [showPreview, setShowPreview] = useState(false);
  const [notification, setNotification] = useState<{type: 'success' | 'error' | 'info', message: string} | null>(null);
  const [bulkGenerating, setBulkGenerating] = useState(false);
  const [bulkProgress, setBulkProgress] = useState<{current: number, total: number, currentReport: string}>({current: 0, total: 0, currentReport: ''});

  const reportTypes: ReportData[] = [
    // User Reports
    {
      id: 'user-summary',
      name: 'User Summary Report',
      description: 'Overview of all registered users, roles, and activity status',
      icon: FiUsers,
      category: 'users'
    },
    {
      id: 'user-registration',
      name: 'User Registration Report',
      description: 'New user registrations over time with demographic breakdown',
      icon: FiTrendingUp,
      category: 'users'
    },
    {
      id: 'user-activity',
      name: 'User Activity Report',
      description: 'User login patterns, session duration, and engagement metrics',
      icon: FiBarChart2,
      category: 'users'
    },
    
    // Job Reports
    {
      id: 'job-postings',
      name: 'Job Postings Report',
      description: 'All job postings with status, employer info, and performance metrics',
      icon: FiBriefcase,
      category: 'jobs'
    },
    {
      id: 'job-performance',
      name: 'Job Performance Report',
      description: 'Job posting views, applications received, and conversion rates',
      icon: FiTrendingUp,
      category: 'jobs'
    },
    {
      id: 'employer-activity',
      name: 'Employer Activity Report',
      description: 'Employer engagement, job posting frequency, and hiring metrics',
      icon: FiUsers,
      category: 'jobs'
    },
    
    // Application Reports
    {
      id: 'application-summary',
      name: 'Application Summary Report',
      description: 'Overview of all job applications with status and outcomes',
      icon: FiFile,
      category: 'applications'
    },
    {
      id: 'application-trends',
      name: 'Application Trends Report',
      description: 'Application patterns, success rates, and seasonal trends',
      icon: FiTrendingUp,
      category: 'applications'
    },
    
    // System Reports
    {
      id: 'system-health',
      name: 'System Health Report',
      description: 'Server performance, database metrics, and system uptime',
      icon: FiBarChart2,
      category: 'system'
    },
    {
      id: 'verification-report',
      name: 'Verification Report',
      description: 'Employer verification status, pending documents, and approval rates',
      icon: FiFileText,
      category: 'system'
    },
    
    // Analytics Reports
    {
      id: 'platform-analytics',
      name: 'Platform Analytics Report',
      description: 'Comprehensive platform usage, growth metrics, and KPIs',
      icon: FiBarChart2,
      category: 'analytics'
    },
    {
      id: 'revenue-analytics',
      name: 'Revenue Analytics Report',
      description: 'Revenue streams, subscription metrics, and financial performance',
      icon: FiTrendingUp,
      category: 'analytics'
    }
  ];

  const dateRangeOptions = [
    // Quick ranges
    { value: 'today', label: 'Today' },
    { value: 'yesterday', label: 'Yesterday' },
    
    // Weekly/Monthly ranges
    { value: 'last7days', label: 'Last 7 Days' },
    { value: 'last30days', label: 'Last 30 Days' },
    
    // Current periods
    { value: 'thisweek', label: 'This Week' },
    { value: 'thismonth', label: 'This Month' },
    { value: 'thisquarter', label: 'This Quarter' },
    { value: 'thisyear', label: 'This Year' },
    
    // Previous periods
    { value: 'lastweek', label: 'Last Week' },
    { value: 'lastmonth', label: 'Last Month' },
    { value: 'lastquarter', label: 'Last Quarter' },
    { value: 'lastyear', label: 'Last Year' },
    
    // Extended ranges
    { value: 'last3months', label: 'Last 3 Months' },
    { value: 'last6months', label: 'Last 6 Months' },
    
    // Custom
    { value: 'custom', label: 'Custom Range' }
  ];

  const formatOptions = [
    { value: 'pdf', label: 'PDF Document' },
    { value: 'csv', label: 'CSV Spreadsheet' },
    { value: 'json', label: 'JSON Data' }
  ];

  useEffect(() => {
    // Set default date range based on selection
    const today = new Date();
    const formatDate = (date: Date) => date.toISOString().split('T')[0];

    switch (filters.dateRange) {
      case 'today':
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(today),
          endDate: formatDate(today)
        }));
        break;
        
      case 'yesterday':
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(yesterday),
          endDate: formatDate(yesterday)
        }));
        break;
        
      case 'last7days':
        const week = new Date(today);
        week.setDate(week.getDate() - 7);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(week),
          endDate: formatDate(today)
        }));
        break;
        
      case 'last30days':
        const month = new Date(today);
        month.setDate(month.getDate() - 30);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(month),
          endDate: formatDate(today)
        }));
        break;
        
      case 'thisweek':
        const startOfWeek = new Date(today);
        const day = startOfWeek.getDay();
        const diff = startOfWeek.getDate() - day + (day === 0 ? -6 : 1); // Monday as first day
        startOfWeek.setDate(diff);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(startOfWeek),
          endDate: formatDate(today)
        }));
        break;
        
      case 'thismonth':
        const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(startOfMonth),
          endDate: formatDate(today)
        }));
        break;
        
      case 'thisquarter':
        const quarterStart = new Date(today.getFullYear(), Math.floor(today.getMonth() / 3) * 3, 1);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(quarterStart),
          endDate: formatDate(today)
        }));
        break;
        
      case 'thisyear':
        const startOfYear = new Date(today.getFullYear(), 0, 1);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(startOfYear),
          endDate: formatDate(today)
        }));
        break;
        
      case 'lastweek':
        const lastWeekEnd = new Date(today);
        const lastWeekStart = new Date(today);
        const dayOfWeek = lastWeekEnd.getDay();
        const daysToSubtract = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Monday as first day
        lastWeekEnd.setDate(lastWeekEnd.getDate() - daysToSubtract - 1);
        lastWeekStart.setDate(lastWeekEnd.getDate() - 6);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(lastWeekStart),
          endDate: formatDate(lastWeekEnd)
        }));
        break;
        
      case 'lastmonth':
        const lastMonthStart = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        const lastMonthEnd = new Date(today.getFullYear(), today.getMonth(), 0);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(lastMonthStart),
          endDate: formatDate(lastMonthEnd)
        }));
        break;
        
      case 'lastquarter':
        const currentQuarter = Math.floor(today.getMonth() / 3);
        const lastQuarterStart = new Date(today.getFullYear(), (currentQuarter - 1) * 3, 1);
        const lastQuarterEnd = new Date(today.getFullYear(), currentQuarter * 3, 0);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(lastQuarterStart),
          endDate: formatDate(lastQuarterEnd)
        }));
        break;
        
      case 'lastyear':
        const lastYearStart = new Date(today.getFullYear() - 1, 0, 1);
        const lastYearEnd = new Date(today.getFullYear() - 1, 11, 31);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(lastYearStart),
          endDate: formatDate(lastYearEnd)
        }));
        break;
        
      case 'last3months':
        const threeMonthsAgo = new Date(today);
        threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(threeMonthsAgo),
          endDate: formatDate(today)
        }));
        break;
        
      case 'last6months':
        const sixMonthsAgo = new Date(today);
        sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
        setFilters(prev => ({
          ...prev,
          startDate: formatDate(sixMonthsAgo),
          endDate: formatDate(today)
        }));
        break;
    }
  }, [filters.dateRange]);

  const handleGenerateReport = async () => {
    if (!filters.reportType) {
      setNotification({type: 'error', message: 'Please select a report type first'});
      return;
    }

    setLoading(true);
    try {
      console.log('Generating report with filters:', filters);
      
      // Call the admin service to generate the report
      const reportData = await adminService.generateReport({
        reportType: filters.reportType,
        startDate: filters.startDate,
        endDate: filters.endDate,
        format: filters.format,
        includeDetails: filters.includeDetails
      });

      // Create download link
      const selectedReport = reportTypes.find(r => r.id === filters.reportType);
      const fileName = `${selectedReport?.name || 'Report'}_${filters.startDate}_to_${filters.endDate}.${filters.format}`;
      
      if (filters.format === 'json') {
        // For JSON, create a downloadable file with the report data
        const blob = new Blob([JSON.stringify(reportData.report, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
      } else if (filters.format === 'csv') {
        // Convert report data to CSV format
        const csvContent = convertToCSV(reportData.report);
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
      } else {
        // For PDF, create a formatted text version for now
        const pdfContent = formatReportForPDF(reportData.report, selectedReport?.name);
        const blob = new Blob([pdfContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName.replace('.pdf', '.txt');
        a.click();
        URL.revokeObjectURL(url);
      }

      // Add to generated reports list
      const newReport = {
        id: Date.now().toString(),
        name: selectedReport?.name || 'Report',
        type: filters.reportType,
        dateRange: `${filters.startDate} to ${filters.endDate}`,
        format: filters.format,
        generatedAt: new Date().toISOString(),
        size: '2.3 MB' // This would come from the actual file
      };
      
      setGeneratedReports(prev => [newReport, ...prev]);
      
      setNotification({type: 'success', message: `${selectedReport?.name} generated successfully!`});
      
      // Auto-hide notification after 3 seconds
      setTimeout(() => setNotification(null), 3000);
    } catch (error) {
      console.error('Error generating report:', error);
      setNotification({type: 'error', message: `Failed to generate report: ${error.message}`});
      
      // Auto-hide notification after 5 seconds
      setTimeout(() => setNotification(null), 5000);
    } finally {
      setLoading(false);
    }
  };

  const getCategoryReports = (category: string) => {
    return reportTypes.filter(report => report.category === category);
  };

  const categories = [
    { id: 'users', name: 'User Reports', icon: FiUsers },
    { id: 'jobs', name: 'Job Reports', icon: FiBriefcase },
    { id: 'applications', name: 'Application Reports', icon: FiFile },
    { id: 'system', name: 'System Reports', icon: FiBarChart2 },
    { id: 'analytics', name: 'Analytics Reports', icon: FiTrendingUp }
  ];

  const handlePreviewReport = async () => {
    if (!filters.reportType) {
      setNotification({type: 'error', message: 'Please select a report type first'});
      return;
    }

    setLoading(true);
    try {
      // Generate a preview with limited data
      const previewFilters = {
        ...filters,
        includeDetails: false // Preview without detailed data
      };
      
      const reportData = await adminService.generateReport(previewFilters);
      setPreviewData(reportData.report);
      setShowPreview(true);
      setNotification({type: 'info', message: 'Report preview generated'});
      setTimeout(() => setNotification(null), 2000);
    } catch (error) {
      console.error('Error generating preview:', error);
      setNotification({type: 'error', message: `Failed to generate preview: ${error.message}`});
      setTimeout(() => setNotification(null), 5000);
    } finally {
      setLoading(false);
    }
  };

  const isFormValid = () => {
    return filters.reportType && filters.startDate && filters.endDate;
  };

  const handleGenerateAllReports = async () => {
    if (!filters.startDate || !filters.endDate) {
      setNotification({type: 'error', message: 'Please set date range first'});
      return;
    }

    setBulkGenerating(true);
    setBulkProgress({current: 0, total: reportTypes.length, currentReport: 'Initializing...'});
    
    try {
      setNotification({type: 'info', message: `Starting bulk generation of ${reportTypes.length} reports...`});
      
      // Simulate progress updates
      const progressInterval = setInterval(() => {
        setBulkProgress(prev => {
          if (prev.current < prev.total - 1) {
            const nextIndex = prev.current + 1;
            return {
              ...prev,
              current: nextIndex,
              currentReport: reportTypes[nextIndex]?.name || 'Processing...'
            };
          }
          return prev;
        });
      }, 800);

      // Call the bulk generation endpoint
      const response = await adminService.generateAllReports({
        startDate: filters.startDate,
        endDate: filters.endDate,
        format: filters.format,
        includeDetails: filters.includeDetails
      });

      clearInterval(progressInterval);
      setBulkProgress({current: reportTypes.length, total: reportTypes.length, currentReport: 'Completing...'});

      const { data } = response;
      
      // Add all reports to the generated reports list
      const newReports = data.reports.map((report: any, index: number) => ({
        id: `${Date.now()}-${index}`,
        name: reportTypes.find(r => r.id === report.reportType)?.name || report.reportType,
        type: report.reportType,
        dateRange: `${filters.startDate} to ${filters.endDate}`,
        format: filters.format,
        generatedAt: new Date().toISOString(),
        size: '2.3 MB'
      }));
      
      setGeneratedReports(prev => [...newReports, ...prev]);

      // Create download file
      const fileName = `All_Reports_${filters.startDate}_to_${filters.endDate}.${filters.format}`;
      
      if (filters.format === 'json') {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
      } else if (filters.format === 'csv') {
        // Convert all reports to CSV
        let csvContent = `All Reports - ${data.metadata.dateRange}\n`;
        csvContent += `Generated: ${new Date(data.metadata.generatedAt).toLocaleString()}\n\n`;
        
        data.reports.forEach((report: any) => {
          csvContent += `\n=== ${report.reportType.toUpperCase()} ===\n`;
          if (report.data.summary) {
            Object.entries(report.data.summary).forEach(([key, value]) => {
              csvContent += `${key},${value}\n`;
            });
          }
        });
        
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
      } else {
        // Create formatted text for PDF
        let textContent = `ALL REPORTS SUMMARY\n${'='.repeat(50)}\n\n`;
        textContent += `Generated: ${new Date(data.metadata.generatedAt).toLocaleString()}\n`;
        textContent += `Date Range: ${data.metadata.dateRange}\n`;
        textContent += `Total Reports: ${data.metadata.totalReports}\n\n`;
        
        data.reports.forEach((report: any) => {
          textContent += `\n${report.reportType.toUpperCase()}\n${'-'.repeat(30)}\n`;
          if (report.data.summary) {
            Object.entries(report.data.summary).forEach(([key, value]) => {
              textContent += `${key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}: ${value}\n`;
            });
          }
          textContent += '\n';
        });
        
        const blob = new Blob([textContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName.replace('.pdf', '.txt');
        a.click();
        URL.revokeObjectURL(url);
      }

      const successMessage = data.failedReports?.length > 0 
        ? `Generated ${data.metadata.totalReports} reports successfully. ${data.failedReports.length} failed.`
        : `All ${data.metadata.totalReports} reports generated successfully! 🎉`;
      
      setNotification({type: 'success', message: successMessage});
      setTimeout(() => setNotification(null), 5000);

    } catch (error) {
      console.error('Bulk generation error:', error);
      setNotification({type: 'error', message: `Bulk generation failed: ${error.message}`});
      setTimeout(() => setNotification(null), 5000);
    } finally {
      setBulkGenerating(false);
      setBulkProgress({current: 0, total: 0, currentReport: ''});
    }
  };

  return (
    <div className="reports-page">
      {/* Notification System */}
      {notification && (
        <div className={`notification ${notification.type}`}>
          <div className="notification-content">
            <span>{notification.message}</span>
            <button 
              className="notification-close"
              onClick={() => setNotification(null)}
            >
              ×
            </button>
          </div>
        </div>
      )}

      {/* Page Header */}
      <div className="page-header">
        <div className="header-content">
          <div className="header-text">
            <h1 className="page-title">Report Generation</h1>
            <p className="page-description">
              Generate comprehensive reports with custom filters and export options. 
              Select a report type, configure your parameters, and download in your preferred format.
            </p>
          </div>
          <div className="header-actions">
            <button 
              onClick={handleGenerateAllReports}
              disabled={bulkGenerating || !filters.startDate || !filters.endDate}
              className="btn btn-primary btn-generate-all"
            >
              {bulkGenerating ? <FiClock className="spinning" /> : <FiDownload />}
              {bulkGenerating ? 'Generating All...' : 'Generate All Reports'}
            </button>
          </div>
        </div>
        
        {/* Bulk Generation Progress */}
        {bulkGenerating && (
          <div className="bulk-progress-card">
            <div className="progress-header">
              <h3>Generating All Reports</h3>
              <span className="progress-counter">
                {bulkProgress.current} of {bulkProgress.total} completed
              </span>
            </div>
            <div className="progress-bar">
              <div 
                className="progress-fill"
                style={{ width: `${(bulkProgress.current / bulkProgress.total) * 100}%` }}
              ></div>
            </div>
            <p className="current-report">
              {bulkProgress.currentReport && `Currently generating: ${bulkProgress.currentReport}`}
            </p>
          </div>
        )}
      </div>

      {/* Main Content */}
      <div className="reports-layout">
        {/* Configuration Sidebar */}
        <div className="config-sidebar">
          <div className="config-card">
            <div className="card-header">
              <h2 className="card-title">
                <FiFilter className="card-icon" />
                Configuration
              </h2>
              <p className="card-description">Set your report parameters</p>
            </div>
            
            <div className="card-content">
              {/* Date Range Section */}
              <div className="config-group">
                <h3 className="group-title">Date Range</h3>
                <div className="form-field">
                  <label className="field-label">Time Period</label>
                  <select 
                    value={filters.dateRange} 
                    onChange={(e) => setFilters(prev => ({ ...prev, dateRange: e.target.value }))}
                    className="form-select"
                  >
                    {dateRangeOptions.map(option => (
                      <option key={option.value} value={option.value}>
                        {option.label}
                      </option>
                    ))}
                  </select>
                </div>

                {filters.dateRange === 'custom' && (
                  <div className="date-range-inputs">
                    <div className="form-field">
                      <label className="field-label">Start Date</label>
                      <input
                        type="date"
                        value={filters.startDate}
                        onChange={(e) => setFilters(prev => ({ ...prev, startDate: e.target.value }))}
                        className="form-input"
                      />
                    </div>
                    <div className="form-field">
                      <label className="field-label">End Date</label>
                      <input
                        type="date"
                        value={filters.endDate}
                        onChange={(e) => setFilters(prev => ({ ...prev, endDate: e.target.value }))}
                        className="form-input"
                      />
                    </div>
                  </div>
                )}
              </div>

              {/* Export Options Section */}
              <div className="config-group">
                <h3 className="group-title">Export Options</h3>
                <div className="form-field">
                  <label className="field-label">Format</label>
                  <select 
                    value={filters.format} 
                    onChange={(e) => setFilters(prev => ({ ...prev, format: e.target.value as 'pdf' | 'csv' | 'json' }))}
                    className="form-select"
                  >
                    {formatOptions.map(option => (
                      <option key={option.value} value={option.value}>
                        {option.label}
                      </option>
                    ))}
                  </select>
                </div>

                <div className="form-field">
                  <label className="checkbox-field">
                    <input
                      type="checkbox"
                      checked={filters.includeDetails}
                      onChange={(e) => setFilters(prev => ({ ...prev, includeDetails: e.target.checked }))}
                      className="checkbox-input"
                    />
                    <span className="checkbox-label">Include detailed data</span>
                  </label>
                </div>
              </div>

              {/* Action Buttons */}
              <div className="action-section">
                <button 
                  onClick={handlePreviewReport}
                  disabled={loading || !isFormValid()}
                  className="btn btn-secondary btn-full"
                >
                  {loading ? <FiClock className="spinning" /> : <FiFileText />}
                  {loading ? 'Loading...' : 'Preview Report'}
                </button>
                
                <button 
                  onClick={handleGenerateReport}
                  disabled={loading || !isFormValid()}
                  className="btn btn-primary btn-full"
                >
                  {loading ? <FiClock className="spinning" /> : <FiDownload />}
                  {loading ? 'Generating...' : 'Generate & Download'}
                </button>
              </div>

              {/* Status Summary */}
              <div className="status-summary">
                <h3 className="group-title">Summary</h3>
                <div className="status-grid">
                  <div className="status-item">
                    <span className="status-label">Report Type</span>
                    <span className="status-value">
                      {filters.reportType ? reportTypes.find(r => r.id === filters.reportType)?.name : 'Not selected'}
                    </span>
                  </div>
                  <div className="status-item">
                    <span className="status-label">Date Range</span>
                    <span className="status-value">
                      {filters.startDate && filters.endDate 
                        ? `${filters.startDate} to ${filters.endDate}` 
                        : 'Not set'
                      }
                    </span>
                  </div>
                  <div className="status-item">
                    <span className="status-label">Format</span>
                    <span className="status-value">{filters.format.toUpperCase()}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Report Selection Area */}
        <div className="reports-main">
          <div className="reports-card">
            <div className="card-header">
              <h2 className="card-title">
                <FiFileText className="card-icon" />
                Available Reports
              </h2>
              <p className="card-description">Choose the type of report you want to generate</p>
            </div>
            
            <div className="card-content">
              {categories.map(category => {
                const categoryReports = getCategoryReports(category.id);
                const CategoryIcon = category.icon;
                
                return (
                  <div key={category.id} className="report-section">
                    <div className="section-header">
                      <h3 className="section-title">
                        <CategoryIcon className="section-icon" />
                        {category.name}
                      </h3>
                    </div>
                    <div className="reports-grid">
                      {categoryReports.map(report => {
                        const ReportIcon = report.icon;
                        return (
                          <div 
                            key={report.id}
                            className={`report-card ${filters.reportType === report.id ? 'selected' : ''}`}
                            onClick={() => setFilters(prev => ({ ...prev, reportType: report.id }))}
                          >
                            <div className="report-card-header">
                              <div className="report-icon">
                                <ReportIcon />
                              </div>
                              <h4 className="report-title">{report.name}</h4>
                            </div>
                            <p className="report-description">{report.description}</p>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      </div>

      {/* Report Preview Modal */}
      {showPreview && previewData && (
        <div className="preview-modal">
          <div className="preview-content">
            <div className="preview-header">
              <h3>Report Preview</h3>
              <button 
                className="close-preview"
                onClick={() => setShowPreview(false)}
              >
                ×
              </button>
            </div>
            <div className="preview-body">
              <div className="preview-metadata">
                <h4>Report Information</h4>
                <p><strong>Type:</strong> {previewData.reportMetadata?.reportType}</p>
                <p><strong>Date Range:</strong> {previewData.reportMetadata?.startDate} to {previewData.reportMetadata?.endDate}</p>
                <p><strong>Generated:</strong> {new Date(previewData.reportMetadata?.generatedAt).toLocaleString()}</p>
              </div>
              
              {previewData.data?.summary && (
                <div className="preview-summary">
                  <h4>Summary Data</h4>
                  <div className="summary-grid">
                    {Object.entries(previewData.data.summary).map(([key, value]) => (
                      <div key={key} className="summary-item">
                        <span className="summary-label">{key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}:</span>
                        <span className="summary-value">{String(value)}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}
              
              <div className="preview-actions">
                <button 
                  onClick={() => {
                    setShowPreview(false);
                    handleGenerateReport();
                  }}
                  className="generate-from-preview-btn"
                >
                  <FiDownload /> Generate Full Report
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Generated Reports History */}
      {generatedReports.length > 0 && (
        <div className="generated-reports">
          <h3><FiCalendar /> Recent Reports ({generatedReports.length})</h3>
          <div className="reports-list">
            {generatedReports.map(report => (
              <div key={report.id} className="report-item">
                <div className="report-details">
                  <h4>{report.name}</h4>
                  <p>Generated: {new Date(report.generatedAt).toLocaleString()}</p>
                  <p>Date Range: {report.dateRange}</p>
                  <span className="report-format">{report.format.toUpperCase()}</span>
                </div>
                <div className="report-actions">
                  <button className="download-btn">
                    <FiDownload /> Re-download
                  </button>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default ReportsTab;
